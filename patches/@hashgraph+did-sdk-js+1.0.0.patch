diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document-json-properties.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document-json-properties.d.ts
new file mode 100644
index 0000000..93cdd8d
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document-json-properties.d.ts
@@ -0,0 +1,12 @@
+export declare module DidDocumentJsonProperties {
+    const CONTEXT = "@context";
+    const ID = "id";
+    const CONTROLLER = "controller";
+    const AUTHENTICATION = "authentication";
+    const VERIFICATION_METHOD = "verificationMethod";
+    const ASSERTION_METHOD = "assertionMethod";
+    const KEY_AGREEMENT = "keyAgreement";
+    const CAPABILITY_INVOCATION = "capabilityInvocation";
+    const CAPABILITY_DELEGATION = "capabilityDelegation";
+    const SERVICE = "service";
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document-json-properties.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document-json-properties.js
new file mode 100644
index 0000000..1e4fa1c
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document-json-properties.js
@@ -0,0 +1,16 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DidDocumentJsonProperties = void 0;
+var DidDocumentJsonProperties;
+(function (DidDocumentJsonProperties) {
+    DidDocumentJsonProperties.CONTEXT = "@context";
+    DidDocumentJsonProperties.ID = "id";
+    DidDocumentJsonProperties.CONTROLLER = "controller";
+    DidDocumentJsonProperties.AUTHENTICATION = "authentication";
+    DidDocumentJsonProperties.VERIFICATION_METHOD = "verificationMethod";
+    DidDocumentJsonProperties.ASSERTION_METHOD = "assertionMethod";
+    DidDocumentJsonProperties.KEY_AGREEMENT = "keyAgreement";
+    DidDocumentJsonProperties.CAPABILITY_INVOCATION = "capabilityInvocation";
+    DidDocumentJsonProperties.CAPABILITY_DELEGATION = "capabilityDelegation";
+    DidDocumentJsonProperties.SERVICE = "service";
+})(DidDocumentJsonProperties = exports.DidDocumentJsonProperties || (exports.DidDocumentJsonProperties = {}));
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document.d.ts
new file mode 100644
index 0000000..55d52ae
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document.d.ts
@@ -0,0 +1,35 @@
+import { Timestamp } from "@hashgraph/sdk";
+import { HcsDidMessage } from "..";
+import { IpfsDidDocumentDownloader } from "../utils/ipfs";
+export declare class DidDocument {
+    private readonly id;
+    private readonly context;
+    private created;
+    private updated;
+    private versionId;
+    private deactivated;
+    private downloader;
+    private controller;
+    private services;
+    private verificationMethods;
+    private verificationRelationships;
+    constructor(did: string);
+    hasOwner(): boolean;
+    getContext(): string;
+    getId(): string;
+    getCreated(): Timestamp;
+    getUpdated(): Timestamp;
+    getVersionId(): string;
+    getDeactivated(): boolean;
+    processMessages(messages: HcsDidMessage[]): Promise<void>;
+    setIpfsDownloader(downloader: IpfsDidDocumentDownloader): void;
+    toJsonTree(): any;
+    toJSON(): string;
+    private setDocumentActivated;
+    private setDocumentDeactivated;
+    private setDocumentUpdated;
+    private processCreateMessage;
+    private processUpdateMessage;
+    private processRevokeMessage;
+    private processDeleteMessage;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document.js
new file mode 100644
index 0000000..e8aabac
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-document.js
@@ -0,0 +1,330 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DidDocument = void 0;
+const __1 = require("..");
+const ipfs_1 = require("../utils/ipfs");
+const did_document_json_properties_1 = require("./did-document-json-properties");
+const did_syntax_1 = require("./did-syntax");
+const hcs_did_event_target_name_1 = require("./hcs/did/event/hcs-did-event-target-name");
+class DidDocument {
+    constructor(did) {
+        this.created = null;
+        this.updated = null;
+        this.versionId = null;
+        this.deactivated = false;
+        this.downloader = new ipfs_1.IpfsDidDocumentDownloader();
+        this.services = new Map();
+        this.verificationMethods = new Map();
+        this.verificationRelationships = {
+            authentication: [],
+            assertionMethod: [],
+            keyAgreement: [],
+            capabilityInvocation: [],
+            capabilityDelegation: [],
+        };
+        this.id = did;
+        this.context = did_syntax_1.DidSyntax.DID_DOCUMENT_CONTEXT;
+    }
+    hasOwner() {
+        return !!this.controller;
+    }
+    getContext() {
+        return this.context;
+    }
+    getId() {
+        return this.id;
+    }
+    getCreated() {
+        return this.created;
+    }
+    getUpdated() {
+        return this.updated;
+    }
+    getVersionId() {
+        return this.versionId;
+    }
+    getDeactivated() {
+        return this.deactivated;
+    }
+    processMessages(messages) {
+        return __awaiter(this, void 0, void 0, function* () {
+            for (const msg of messages) {
+                if (!this.controller &&
+                    msg.getOperation() === __1.DidMethodOperation.CREATE &&
+                    msg.getEvent().targetName !== hcs_did_event_target_name_1.HcsDidEventTargetName.DID_OWNER &&
+                    msg.getEvent().targetName !== hcs_did_event_target_name_1.HcsDidEventTargetName.DID_DOCUMENT) {
+                    console.warn("DID document owner is not registered. Event will be ignored...");
+                    continue;
+                }
+                switch (msg.getOperation()) {
+                    case __1.DidMethodOperation.CREATE:
+                        yield this.processCreateMessage(msg);
+                        continue;
+                    case __1.DidMethodOperation.UPDATE:
+                        yield this.processUpdateMessage(msg);
+                        continue;
+                    case __1.DidMethodOperation.REVOKE:
+                        yield this.processRevokeMessage(msg);
+                        continue;
+                    case __1.DidMethodOperation.DELETE:
+                        yield this.processDeleteMessage(msg);
+                        continue;
+                    default:
+                        console.warn(`Operation ${msg.getOperation()} is not supported. Event will be ignored...`);
+                }
+            }
+        });
+    }
+    setIpfsDownloader(downloader) {
+        this.downloader = downloader;
+    }
+    toJsonTree() {
+        var _a;
+        let rootObject = {};
+        rootObject[did_document_json_properties_1.DidDocumentJsonProperties.CONTEXT] = this.context;
+        rootObject[did_document_json_properties_1.DidDocumentJsonProperties.ID] = this.id;
+        if (this.controller && this.id !== this.controller && this.id !== this.controller.controller) {
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.CONTROLLER] = (_a = this.controller.controller) !== null && _a !== void 0 ? _a : this.controller;
+        }
+        rootObject[did_document_json_properties_1.DidDocumentJsonProperties.VERIFICATION_METHOD] = Array.from(this.verificationMethods.values());
+        rootObject[did_document_json_properties_1.DidDocumentJsonProperties.ASSERTION_METHOD] = [
+            ...this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.ASSERTION_METHOD],
+        ];
+        rootObject[did_document_json_properties_1.DidDocumentJsonProperties.AUTHENTICATION] = [
+            ...this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.AUTHENTICATION],
+        ];
+        if (this.controller) {
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.VERIFICATION_METHOD].unshift(this.controller);
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.ASSERTION_METHOD].unshift(this.controller.id);
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.AUTHENTICATION].unshift(this.controller.id);
+        }
+        if (this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.KEY_AGREEMENT].length > 0) {
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.KEY_AGREEMENT] = [
+                ...this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.KEY_AGREEMENT],
+            ];
+        }
+        if (this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_INVOCATION].length > 0) {
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_INVOCATION] = [
+                ...this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_INVOCATION],
+            ];
+        }
+        if (this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_DELEGATION].length > 0) {
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_DELEGATION] = [
+                ...this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_DELEGATION],
+            ];
+        }
+        if (this.services.size > 0) {
+            rootObject[did_document_json_properties_1.DidDocumentJsonProperties.SERVICE] = [...Array.from(this.services.values())];
+        }
+        return rootObject;
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    setDocumentActivated(message) {
+        const timestamp = message.getTimestamp();
+        this.created = timestamp;
+        this.updated = timestamp;
+        this.deactivated = false;
+        this.versionId = timestamp.toDate().getTime().toString();
+    }
+    setDocumentDeactivated() {
+        this.created = null;
+        this.updated = null;
+        this.deactivated = true;
+        this.versionId = null;
+    }
+    setDocumentUpdated(message) {
+        const timestamp = message.getTimestamp();
+        this.updated = timestamp;
+        this.versionId = timestamp.toDate().getTime().toString();
+    }
+    processCreateMessage(message) {
+        var _a, _b, _c, _d, _e, _f, _g;
+        return __awaiter(this, void 0, void 0, function* () {
+            const event = message.getEvent();
+            switch (event.targetName) {
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.DID_DOCUMENT:
+                    const doc = yield this.downloader.downloadDocument(event);
+                    if (doc[did_document_json_properties_1.DidDocumentJsonProperties.ID] !== this.id) {
+                        throw new Error("Document ID does not match did");
+                    }
+                    this.controller = doc[did_document_json_properties_1.DidDocumentJsonProperties.CONTROLLER];
+                    this.services = new Map(((_a = doc[did_document_json_properties_1.DidDocumentJsonProperties.SERVICE]) !== null && _a !== void 0 ? _a : []).map((service) => [service.id, service]));
+                    this.verificationMethods = new Map(((_b = doc[did_document_json_properties_1.DidDocumentJsonProperties.VERIFICATION_METHOD]) !== null && _b !== void 0 ? _b : []).map((verificationMethod) => [
+                        verificationMethod.id,
+                        verificationMethod,
+                    ]));
+                    this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.ASSERTION_METHOD] =
+                        (_c = doc[did_document_json_properties_1.DidDocumentJsonProperties.ASSERTION_METHOD]) !== null && _c !== void 0 ? _c : [];
+                    this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.AUTHENTICATION] =
+                        (_d = doc[did_document_json_properties_1.DidDocumentJsonProperties.AUTHENTICATION]) !== null && _d !== void 0 ? _d : [];
+                    this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.KEY_AGREEMENT] =
+                        (_e = doc[did_document_json_properties_1.DidDocumentJsonProperties.KEY_AGREEMENT]) !== null && _e !== void 0 ? _e : [];
+                    this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_INVOCATION] =
+                        (_f = doc[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_INVOCATION]) !== null && _f !== void 0 ? _f : [];
+                    this.verificationRelationships[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_DELEGATION] =
+                        (_g = doc[did_document_json_properties_1.DidDocumentJsonProperties.CAPABILITY_DELEGATION]) !== null && _g !== void 0 ? _g : [];
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.DID_OWNER:
+                    if (this.controller) {
+                        console.warn(`DID owner is already registered: ${this.controller}. Event will be ignored...`);
+                        return;
+                    }
+                    this.controller = event.getOwnerDef();
+                    this.setDocumentActivated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE:
+                    if (this.services.has(event.getId())) {
+                        console.warn(`Duplicate create Service event ID: ${event.getId()}. Event will be ignored...`);
+                        return;
+                    }
+                    this.services.set(event.getId(), event.getServiceDef());
+                    this.setDocumentUpdated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD:
+                    if (this.verificationMethods.has(event.getId())) {
+                        console.warn(`Duplicate create VerificationMethod event ID: ${event.getId()}. Event will be ignored...`);
+                        return;
+                    }
+                    this.verificationMethods.set(event.getId(), event.getVerificationMethodDef());
+                    this.setDocumentUpdated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP:
+                    const type = event.getRelationshipType();
+                    if (this.verificationRelationships[type]) {
+                        if (this.verificationRelationships[type].includes(event.getId())) {
+                            console.warn(`Duplicate create VerificationRelationship event ID: ${event.getId()}. Event will be ignored...`);
+                            return;
+                        }
+                        this.verificationRelationships[type].push(event.getId());
+                        if (!this.verificationMethods.has(event.getId())) {
+                            this.verificationMethods.set(event.getId(), event.getVerificationMethodDef());
+                        }
+                        this.setDocumentUpdated(message);
+                    }
+                    else {
+                        console.warn(`Create verificationRelationship event with type ${type} is not supported. Event will be ignored...`);
+                    }
+                    return;
+                default:
+                    console.warn(`Create ${event.targetName} operation is not supported. Event will be ignored...`);
+            }
+        });
+    }
+    processUpdateMessage(message) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const event = message.getEvent();
+            switch (event.targetName) {
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.DID_OWNER:
+                    this.controller = event.getOwnerDef();
+                    this.setDocumentUpdated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE:
+                    if (!this.services.has(event.getId())) {
+                        console.warn(`Update Service event: service with ID ${event.getId()} was not found in the document. Event will be ignored...`);
+                        return;
+                    }
+                    this.services.set(event.getId(), event.getServiceDef());
+                    this.setDocumentUpdated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD:
+                    if (!this.verificationMethods.has(event.getId())) {
+                        console.warn(`Update VerificationMethod event: verificationMethod with ID: ${event.getId()} was not found in the document. Event will be ignored...`);
+                        return;
+                    }
+                    this.verificationMethods.set(event.getId(), event.getVerificationMethodDef());
+                    this.setDocumentUpdated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP:
+                    const type = event.getRelationshipType();
+                    if (this.verificationRelationships[type]) {
+                        if (!this.verificationRelationships[type].includes(event.getId())) {
+                            console.warn(`Update VerificationRelationship event: verificationRelationship with ID: ${event.getId()} was not found in the document.  Event will be ignored...`);
+                            return;
+                        }
+                        this.verificationMethods.set(event.getId(), event.getVerificationMethodDef());
+                        this.setDocumentUpdated(message);
+                    }
+                    else {
+                        console.warn(`Update verificationRelationship event with type ${type} is not supported. Event will be ignored...`);
+                    }
+                    return;
+                default:
+                    console.warn(`Update ${event.targetName} operation is not supported. Event will be ignored...`);
+            }
+        });
+    }
+    processRevokeMessage(message) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const event = message.getEvent();
+            switch (event.targetName) {
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE:
+                    if (!this.services.has(event.getId())) {
+                        console.warn(`Revoke Service event: service event ID: ${event.getId()}. Event will be ignored...`);
+                        return;
+                    }
+                    this.services.delete(event.getId());
+                    this.setDocumentUpdated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD:
+                    if (!this.verificationMethods.has(event.getId())) {
+                        console.warn(`Revoke VerificationMethod event: verificationMethod with ID: ${event.getId()}. Event will be ignored...`);
+                        return;
+                    }
+                    this.verificationMethods.delete(event.getId());
+                    Object.keys(this.verificationRelationships).forEach((relName) => {
+                        this.verificationRelationships[relName] = this.verificationRelationships[relName].filter((id) => id !== event.getId());
+                    });
+                    this.setDocumentUpdated(message);
+                    return;
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP:
+                    const type = event.getRelationshipType();
+                    if (this.verificationRelationships[type]) {
+                        if (!this.verificationRelationships[type].includes(event.getId())) {
+                            console.warn(`Revoke VerificationRelationship event: verificationRelationship with ID: ${event.getId()}. Event will be ignored...`);
+                            return;
+                        }
+                        this.verificationRelationships[type] = this.verificationRelationships[type].filter((id) => id !== event.getId());
+                        const canRemoveVerificationMethod = Object.values(this.verificationRelationships).every((rel) => !rel.includes(event.getId()));
+                        if (canRemoveVerificationMethod) {
+                            this.verificationMethods.delete(event.getId());
+                        }
+                        this.setDocumentUpdated(message);
+                    }
+                    else {
+                        console.warn(`Revoke verificationRelationship event with type ${type} is not supported. Event will be ignored...`);
+                    }
+                    return;
+                default:
+                    console.warn(`Revoke ${event.targetName} operation is not supported. Event will be ignored...`);
+            }
+        });
+    }
+    processDeleteMessage(message) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const event = message.getEvent();
+            switch (event.targetName) {
+                case hcs_did_event_target_name_1.HcsDidEventTargetName.Document:
+                    this.controller = null;
+                    this.services.clear();
+                    this.verificationMethods.clear();
+                    Object.keys(this.verificationRelationships).forEach((relName) => (this.verificationRelationships[relName] = []));
+                    this.setDocumentDeactivated();
+                    return;
+                default:
+                    console.warn(`Delete ${event.targetName} operation is not supported. Event will be ignored...`);
+            }
+        });
+    }
+}
+exports.DidDocument = DidDocument;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-error.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-error.d.ts
new file mode 100644
index 0000000..a95673c
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-error.d.ts
@@ -0,0 +1,13 @@
+export declare enum DidErrorCode {
+    GENERIC = "generic",
+    INVALID_DID_STRING = "invalid_did_string",
+    INVALID_NETWORK = "invalid_network",
+    /**
+     * DID_NOT_FOUND is not thrown anywhere at the moment
+     */
+    DID_NOT_FOUND = "did_not_found"
+}
+export declare class DidError extends Error {
+    code: DidErrorCode;
+    constructor(message: string, code?: DidErrorCode);
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-error.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-error.js
new file mode 100644
index 0000000..818264a
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-error.js
@@ -0,0 +1,20 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DidError = exports.DidErrorCode = void 0;
+var DidErrorCode;
+(function (DidErrorCode) {
+    DidErrorCode["GENERIC"] = "generic";
+    DidErrorCode["INVALID_DID_STRING"] = "invalid_did_string";
+    DidErrorCode["INVALID_NETWORK"] = "invalid_network";
+    /**
+     * DID_NOT_FOUND is not thrown anywhere at the moment
+     */
+    DidErrorCode["DID_NOT_FOUND"] = "did_not_found";
+})(DidErrorCode = exports.DidErrorCode || (exports.DidErrorCode = {}));
+class DidError extends Error {
+    constructor(message, code = DidErrorCode.GENERIC) {
+        super(message);
+        this.code = code;
+    }
+}
+exports.DidError = DidError;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-method-operation.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-method-operation.d.ts
new file mode 100644
index 0000000..9e33fa6
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-method-operation.d.ts
@@ -0,0 +1,7 @@
+export declare enum DidMethodOperation {
+    CREATE = "create",
+    CREATE_DID_DOCUMENT = "create-did-document",
+    UPDATE = "update",
+    DELETE = "delete",
+    REVOKE = "revoke"
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-method-operation.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-method-operation.js
new file mode 100644
index 0000000..6038f8e
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-method-operation.js
@@ -0,0 +1,11 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DidMethodOperation = void 0;
+var DidMethodOperation;
+(function (DidMethodOperation) {
+    DidMethodOperation["CREATE"] = "create";
+    DidMethodOperation["CREATE_DID_DOCUMENT"] = "create-did-document";
+    DidMethodOperation["UPDATE"] = "update";
+    DidMethodOperation["DELETE"] = "delete";
+    DidMethodOperation["REVOKE"] = "revoke";
+})(DidMethodOperation = exports.DidMethodOperation || (exports.DidMethodOperation = {}));
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-parser.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-parser.d.ts
new file mode 100644
index 0000000..e592d14
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-parser.d.ts
@@ -0,0 +1,10 @@
+import { HcsDid } from "./hcs/did/hcs-did";
+/**
+ * Parses the given DID string into it's corresponding Hedera DID object.
+ *
+ * @param didString DID string.
+ * @return {@link HederaDid} instance.
+ */
+export declare class DidParser {
+    static parse(didString: string): HcsDid;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-parser.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-parser.js
new file mode 100644
index 0000000..ec688bd
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-parser.js
@@ -0,0 +1,27 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DidParser = void 0;
+const did_error_1 = require("./did-error");
+const did_syntax_1 = require("./did-syntax");
+const hcs_did_1 = require("./hcs/did/hcs-did");
+/**
+ * Parses the given DID string into it's corresponding Hedera DID object.
+ *
+ * @param didString DID string.
+ * @return {@link HederaDid} instance.
+ */
+class DidParser {
+    static parse(didString) {
+        const methodIndex = did_syntax_1.DidSyntax.DID_PREFIX.length + 1;
+        if (!didString || didString.length <= methodIndex) {
+            throw new did_error_1.DidError("DID string cannot be null");
+        }
+        if (didString.startsWith(hcs_did_1.HcsDid.DID_METHOD + did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR, methodIndex)) {
+            return new hcs_did_1.HcsDid({ identifier: didString });
+        }
+        else {
+            throw new did_error_1.DidError("DID string is invalid.");
+        }
+    }
+}
+exports.DidParser = DidParser;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-resolver.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-resolver.d.ts
new file mode 100644
index 0000000..f913b59
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-resolver.d.ts
@@ -0,0 +1,27 @@
+import { Client } from "@hashgraph/sdk";
+import { DIDResolutionOptions, DIDResolutionResult, DIDResolver, ParsedDID, Resolvable } from "did-resolver";
+export declare enum Errors {
+    /**
+     * The resolver has failed to construct the DID document.
+     * This can be caused by a network issue, a wrong registry address or malformed logs while parsing the registry history.
+     * Please inspect the `DIDResolutionMetadata.message` to debug further.
+     */
+    notFound = "notFound",
+    /**
+     * The resolver does not know how to resolve the given DID. Most likely it is not a `did:hedera`.
+     */
+    invalidDid = "invalidDid",
+    /**
+     * The resolver is misconfigured or is being asked to resolve a DID anchored on an unknown network
+     */
+    unknownNetwork = "unknownNetwork"
+}
+export declare function getResolver(client?: Client): Record<string, DIDResolver>;
+export declare class HederaDidResolver {
+    private client;
+    constructor(client?: Client);
+    getClient(networkName: string): Client;
+    resolve(did: string, _parsed: ParsedDID, _unused: Resolvable, options: DIDResolutionOptions): Promise<DIDResolutionResult>;
+    build(): Record<string, DIDResolver>;
+    private getErrorCode;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-resolver.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-resolver.js
new file mode 100644
index 0000000..280cb68
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-resolver.js
@@ -0,0 +1,97 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HederaDidResolver = exports.getResolver = exports.Errors = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const did_error_1 = require("./did-error");
+const did_syntax_1 = require("./did-syntax");
+const hcs_did_1 = require("./hcs/did/hcs-did");
+var Errors;
+(function (Errors) {
+    /**
+     * The resolver has failed to construct the DID document.
+     * This can be caused by a network issue, a wrong registry address or malformed logs while parsing the registry history.
+     * Please inspect the `DIDResolutionMetadata.message` to debug further.
+     */
+    Errors["notFound"] = "notFound";
+    /**
+     * The resolver does not know how to resolve the given DID. Most likely it is not a `did:hedera`.
+     */
+    Errors["invalidDid"] = "invalidDid";
+    /**
+     * The resolver is misconfigured or is being asked to resolve a DID anchored on an unknown network
+     */
+    Errors["unknownNetwork"] = "unknownNetwork";
+})(Errors = exports.Errors || (exports.Errors = {}));
+function getResolver(client) {
+    return new HederaDidResolver(client).build();
+}
+exports.getResolver = getResolver;
+class HederaDidResolver {
+    constructor(client) {
+        this.client = client;
+    }
+    getClient(networkName) {
+        if (this.client) {
+            return this.client;
+        }
+        return sdk_1.Client.forName(networkName);
+    }
+    resolve(did, _parsed, _unused, options) {
+        var _a, _b, _c, _d;
+        return __awaiter(this, void 0, void 0, function* () {
+            const networkName = did === null || did === void 0 ? void 0 : did.split(did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR)[2];
+            const client = this.getClient(networkName);
+            try {
+                const registeredDid = new hcs_did_1.HcsDid({ identifier: did, client: client });
+                const didDocument = yield registeredDid.resolve();
+                const status = didDocument.getDeactivated() ? { deactivated: true } : {};
+                let documentMeta = {
+                    versionId: didDocument.getVersionId(),
+                };
+                if (!status.deactivated) {
+                    documentMeta = Object.assign(Object.assign({}, documentMeta), { created: (_b = (_a = didDocument.getCreated()) === null || _a === void 0 ? void 0 : _a.toDate()) === null || _b === void 0 ? void 0 : _b.toISOString(), updated: (_d = (_c = didDocument.getUpdated()) === null || _c === void 0 ? void 0 : _c.toDate()) === null || _d === void 0 ? void 0 : _d.toISOString() });
+                }
+                return {
+                    didDocumentMetadata: Object.assign(Object.assign({}, status), documentMeta),
+                    didResolutionMetadata: { contentType: "application/did+ld+json" },
+                    didDocument: didDocument.toJsonTree(),
+                };
+            }
+            catch (e) {
+                return {
+                    didResolutionMetadata: {
+                        error: this.getErrorCode(e),
+                        message: e.toString(), // This is not in spec, but may be helpful
+                    },
+                    didDocumentMetadata: {},
+                    didDocument: null,
+                };
+            }
+        });
+    }
+    build() {
+        return { hedera: this.resolve.bind(this) };
+    }
+    getErrorCode(error) {
+        switch (error === null || error === void 0 ? void 0 : error.code) {
+            case did_error_1.DidErrorCode.INVALID_DID_STRING:
+                return Errors.invalidDid;
+            case did_error_1.DidErrorCode.INVALID_NETWORK:
+                return Errors.unknownNetwork;
+            case did_error_1.DidErrorCode.DID_NOT_FOUND:
+                return Errors.notFound;
+            default:
+                return Errors.notFound;
+        }
+    }
+}
+exports.HederaDidResolver = HederaDidResolver;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-syntax.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-syntax.d.ts
new file mode 100644
index 0000000..d317c5d
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-syntax.d.ts
@@ -0,0 +1,12 @@
+export declare module DidSyntax {
+    const DID_PREFIX = "did";
+    const DID_DOCUMENT_CONTEXT = "https://www.w3.org/ns/did/v1";
+    const DID_METHOD_SEPARATOR = ":";
+    const DID_TOPIC_SEPARATOR = "_";
+    const HEDERA_NETWORK_MAINNET = "mainnet";
+    const HEDERA_NETWORK_TESTNET = "testnet";
+    const HEDERA_NETWORK_PREVIEWNET = "previewnet";
+    enum Method {
+        HEDERA_HCS = "hedera"
+    }
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/did-syntax.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-syntax.js
new file mode 100644
index 0000000..35957ff
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/did-syntax.js
@@ -0,0 +1,17 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DidSyntax = void 0;
+var DidSyntax;
+(function (DidSyntax) {
+    DidSyntax.DID_PREFIX = "did";
+    DidSyntax.DID_DOCUMENT_CONTEXT = "https://www.w3.org/ns/did/v1";
+    DidSyntax.DID_METHOD_SEPARATOR = ":";
+    DidSyntax.DID_TOPIC_SEPARATOR = "_";
+    DidSyntax.HEDERA_NETWORK_MAINNET = "mainnet";
+    DidSyntax.HEDERA_NETWORK_TESTNET = "testnet";
+    DidSyntax.HEDERA_NETWORK_PREVIEWNET = "previewnet";
+    let Method;
+    (function (Method) {
+        Method["HEDERA_HCS"] = "hedera";
+    })(Method = DidSyntax.Method || (DidSyntax.Method = {}));
+})(DidSyntax = exports.DidSyntax || (exports.DidSyntax = {}));
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-create-did-document-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-create-did-document-event.d.ts
new file mode 100644
index 0000000..b4106c0
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-create-did-document-event.d.ts
@@ -0,0 +1,25 @@
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+export declare class HcsDidCreateDidDocumentEvent extends HcsDidEvent {
+    static DID_DOCUMENT_TYPE: string;
+    readonly targetName = HcsDidEventTargetName.DID_DOCUMENT;
+    protected id: string;
+    protected type: string;
+    protected cid: string;
+    protected url: string;
+    constructor(id: string, cid: string, url?: string);
+    getId(): string;
+    getType(): string;
+    getCid(): string;
+    getUrl(): string;
+    toJsonTree(): {
+        DIDDocument: {
+            id: string;
+            type: string;
+            cid: string;
+            url: string;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidCreateDidDocumentEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-create-did-document-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-create-did-document-event.js
new file mode 100644
index 0000000..03971e8
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-create-did-document-event.js
@@ -0,0 +1,52 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidCreateDidDocumentEvent = void 0;
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidCreateDidDocumentEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id, cid, url) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.DID_DOCUMENT;
+        this.type = HcsDidCreateDidDocumentEvent.DID_DOCUMENT_TYPE;
+        if (!id || !cid) {
+            throw new did_error_1.DidError("Validation failed. DID Document args are missing");
+        }
+        if (!this.isDidValid(id)) {
+            throw new did_error_1.DidError("DID is invalid");
+        }
+        this.id = id;
+        this.cid = cid;
+        this.url = url;
+    }
+    getId() {
+        return this.id;
+    }
+    getType() {
+        return this.type;
+    }
+    getCid() {
+        return this.cid;
+    }
+    getUrl() {
+        return this.url;
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+                type: this.getType(),
+                cid: this.getCid(),
+                url: this.getUrl(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        return new HcsDidCreateDidDocumentEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.cid, tree === null || tree === void 0 ? void 0 : tree.url);
+    }
+}
+exports.HcsDidCreateDidDocumentEvent = HcsDidCreateDidDocumentEvent;
+HcsDidCreateDidDocumentEvent.DID_DOCUMENT_TYPE = "DIDDocument";
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-delete-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-delete-event.d.ts
new file mode 100644
index 0000000..b782232
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-delete-event.d.ts
@@ -0,0 +1,11 @@
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+export declare class HcsDidDeleteEvent extends HcsDidEvent {
+    readonly targetName = HcsDidEventTargetName.Document;
+    constructor();
+    getId(): string;
+    toJsonTree(): any;
+    toJSON(): string;
+    getBase64(): any;
+    static fromJsonTree(tree: any): HcsDidDeleteEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-delete-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-delete-event.js
new file mode 100644
index 0000000..0df2d49
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/document/hcs-did-delete-event.js
@@ -0,0 +1,27 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidDeleteEvent = void 0;
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidDeleteEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor() {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.Document;
+    }
+    getId() {
+        return undefined;
+    }
+    toJsonTree() {
+        return null;
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    getBase64() {
+        return null;
+    }
+    static fromJsonTree(tree) {
+        return new HcsDidDeleteEvent();
+    }
+}
+exports.HcsDidDeleteEvent = HcsDidDeleteEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-parser.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-parser.d.ts
new file mode 100644
index 0000000..37ee248
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-parser.d.ts
@@ -0,0 +1,5 @@
+import { DidMethodOperation } from "../../../did-method-operation";
+import { HcsDidEvent } from "./hcs-did-event";
+export declare class HcsDidEventParser {
+    static fromBase64(operation: DidMethodOperation, eventBase64: any): HcsDidEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-parser.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-parser.js
new file mode 100644
index 0000000..e1c75d9
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-parser.js
@@ -0,0 +1,56 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidEventParser = void 0;
+const hashing_1 = require("../../../../utils/hashing");
+const did_method_operation_1 = require("../../../did-method-operation");
+const hcs_did_create_did_document_event_1 = require("./document/hcs-did-create-did-document-event");
+const hcs_did_delete_event_1 = require("./document/hcs-did-delete-event");
+const hcs_did_event_target_name_1 = require("./hcs-did-event-target-name");
+const hcs_did_create_did_owner_event_1 = require("./owner/hcs-did-create-did-owner-event");
+const hcs_did_update_did_owner_event_1 = require("./owner/hcs-did-update-did-owner-event");
+const hcs_did_create_service_event_1 = require("./service/hcs-did-create-service-event");
+const hcs_did_revoke_service_event_1 = require("./service/hcs-did-revoke-service-event");
+const hcs_did_update_service_event_1 = require("./service/hcs-did-update-service-event");
+const hcs_did_create_verification_method_event_1 = require("./verification-method/hcs-did-create-verification-method-event");
+const hcs_did_revoke_verification_method_event_1 = require("./verification-method/hcs-did-revoke-verification-method-event");
+const hcs_did_update_verification_method_event_1 = require("./verification-method/hcs-did-update-verification-method-event");
+const hcs_did_create_verification_relationship_event_1 = require("./verification-relationship/hcs-did-create-verification-relationship-event");
+const hcs_did_revoke_verification_relationship_event_1 = require("./verification-relationship/hcs-did-revoke-verification-relationship-event");
+const hcs_did_update_verification_relationship_event_1 = require("./verification-relationship/hcs-did-update-verification-relationship-event");
+const EVENT_NAME_TO_CLASS = {
+    [did_method_operation_1.DidMethodOperation.CREATE]: {
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.DID_OWNER]: hcs_did_create_did_owner_event_1.HcsDidCreateDidOwnerEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.DID_DOCUMENT]: hcs_did_create_did_document_event_1.HcsDidCreateDidDocumentEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE]: hcs_did_create_service_event_1.HcsDidCreateServiceEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD]: hcs_did_create_verification_method_event_1.HcsDidCreateVerificationMethodEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP]: hcs_did_create_verification_relationship_event_1.HcsDidCreateVerificationRelationshipEvent,
+    },
+    [did_method_operation_1.DidMethodOperation.UPDATE]: {
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.DID_OWNER]: hcs_did_update_did_owner_event_1.HcsDidUpdateDidOwnerEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE]: hcs_did_update_service_event_1.HcsDidUpdateServiceEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD]: hcs_did_update_verification_method_event_1.HcsDidUpdateVerificationMethodEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP]: hcs_did_update_verification_relationship_event_1.HcsDidUpdateVerificationRelationshipEvent,
+    },
+    [did_method_operation_1.DidMethodOperation.REVOKE]: {
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE]: hcs_did_revoke_service_event_1.HcsDidRevokeServiceEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD]: hcs_did_revoke_verification_method_event_1.HcsDidRevokeVerificationMethodEvent,
+        [hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP]: hcs_did_revoke_verification_relationship_event_1.HcsDidRevokeVerificationRelationshipEvent,
+    },
+};
+class HcsDidEventParser {
+    static fromBase64(operation, eventBase64) {
+        if (operation === did_method_operation_1.DidMethodOperation.DELETE) {
+            return hcs_did_delete_event_1.HcsDidDeleteEvent.fromJsonTree(null);
+        }
+        try {
+            const tree = JSON.parse(hashing_1.Hashing.base64.decode(eventBase64));
+            const eventsByOperation = EVENT_NAME_TO_CLASS[operation];
+            const eventTargetName = Object.keys(eventsByOperation).find((etn) => !!tree[etn]);
+            return eventsByOperation[eventTargetName].fromJsonTree(tree[eventTargetName]);
+        }
+        catch (_a) {
+            return null;
+        }
+    }
+}
+exports.HcsDidEventParser = HcsDidEventParser;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-target-name.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-target-name.d.ts
new file mode 100644
index 0000000..9260ff2
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-target-name.d.ts
@@ -0,0 +1,8 @@
+export declare enum HcsDidEventTargetName {
+    DID_DOCUMENT = "DIDDocument",
+    DID_OWNER = "DIDOwner",
+    VERIFICATION_METHOD = "VerificationMethod",
+    VERIFICATION_RELATIONSHIP = "VerificationRelationship",
+    SERVICE = "Service",
+    Document = "Document"
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-target-name.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-target-name.js
new file mode 100644
index 0000000..7fb3b29
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event-target-name.js
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidEventTargetName = void 0;
+var HcsDidEventTargetName;
+(function (HcsDidEventTargetName) {
+    HcsDidEventTargetName["DID_DOCUMENT"] = "DIDDocument";
+    HcsDidEventTargetName["DID_OWNER"] = "DIDOwner";
+    HcsDidEventTargetName["VERIFICATION_METHOD"] = "VerificationMethod";
+    HcsDidEventTargetName["VERIFICATION_RELATIONSHIP"] = "VerificationRelationship";
+    HcsDidEventTargetName["SERVICE"] = "Service";
+    HcsDidEventTargetName["Document"] = "Document";
+})(HcsDidEventTargetName = exports.HcsDidEventTargetName || (exports.HcsDidEventTargetName = {}));
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event.d.ts
new file mode 100644
index 0000000..cc27780
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event.d.ts
@@ -0,0 +1,17 @@
+import { HcsDidEventTargetName } from "./hcs-did-event-target-name";
+export declare abstract class HcsDidEvent {
+    protected SERVICE_ID_POSTFIX_REGEX: RegExp;
+    protected KEY_ID_POSTFIX_REGEX: RegExp;
+    protected OWNER_KEY_POSTFIX_REGEX: RegExp;
+    abstract readonly targetName: HcsDidEventTargetName;
+    constructor();
+    abstract getId(): string;
+    abstract toJsonTree(): any;
+    abstract toJSON(): string;
+    getBase64(): string;
+    static fromJsonTree(tree: any): HcsDidEvent;
+    protected isDidValid(eventId: string): boolean;
+    protected isOwnerEventIdValid(eventId: string): boolean;
+    protected isServiceEventIdValid(eventId: string): boolean;
+    protected isKeyEventIdValid(eventId: string): boolean;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event.js
new file mode 100644
index 0000000..bdc622d
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/hcs-did-event.js
@@ -0,0 +1,51 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidEvent = void 0;
+const hashing_1 = require("../../../../utils/hashing");
+const hcs_did_1 = require("../hcs-did");
+class HcsDidEvent {
+    constructor() {
+        this.SERVICE_ID_POSTFIX_REGEX = /^(service)\-[0-9]{1,}$/;
+        this.KEY_ID_POSTFIX_REGEX = /^(key)\-[0-9]{1,}$/;
+        this.OWNER_KEY_POSTFIX_REGEX = /^(did\-root\-key)$/;
+    }
+    getBase64() {
+        return hashing_1.Hashing.base64.encode(this.toJSON());
+    }
+    static fromJsonTree(tree) {
+        throw new Error("not implemented");
+    }
+    isDidValid(eventId) {
+        const [identifier, id] = eventId === null || eventId === void 0 ? void 0 : eventId.split("#");
+        if (!identifier) {
+            return false;
+        }
+        hcs_did_1.HcsDid.parseIdentifier(identifier);
+        return true;
+    }
+    isOwnerEventIdValid(eventId) {
+        const [identifier, id] = eventId === null || eventId === void 0 ? void 0 : eventId.split("#");
+        if (!identifier || !id) {
+            return false;
+        }
+        hcs_did_1.HcsDid.parseIdentifier(identifier);
+        return this.OWNER_KEY_POSTFIX_REGEX.test(id) !== false;
+    }
+    isServiceEventIdValid(eventId) {
+        const [identifier, id] = eventId === null || eventId === void 0 ? void 0 : eventId.split("#");
+        if (!identifier || !id) {
+            return false;
+        }
+        hcs_did_1.HcsDid.parseIdentifier(identifier);
+        return this.SERVICE_ID_POSTFIX_REGEX.test(id) !== false;
+    }
+    isKeyEventIdValid(eventId) {
+        const [identifier, id] = eventId === null || eventId === void 0 ? void 0 : eventId.split("#");
+        if (!identifier || !id) {
+            return false;
+        }
+        hcs_did_1.HcsDid.parseIdentifier(identifier);
+        return this.KEY_ID_POSTFIX_REGEX.test(id) !== false;
+    }
+}
+exports.HcsDidEvent = HcsDidEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-create-did-owner-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-create-did-owner-event.d.ts
new file mode 100644
index 0000000..ba481d1
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-create-did-owner-event.d.ts
@@ -0,0 +1,33 @@
+import { PublicKey } from "@hashgraph/sdk";
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+export declare class HcsDidCreateDidOwnerEvent extends HcsDidEvent {
+    static KEY_TYPE: string;
+    readonly targetName = HcsDidEventTargetName.DID_OWNER;
+    protected id: string;
+    protected type: string;
+    protected controller: string;
+    protected publicKey: PublicKey;
+    constructor(id: string, controller: string, publicKey: PublicKey);
+    getId(): string;
+    getType(): string;
+    getController(): string;
+    getPublicKey(): PublicKey;
+    getPublicKeyBase58(): string;
+    getOwnerDef(): {
+        id: string;
+        type: string;
+        controller: string;
+        publicKeyBase58: string;
+    };
+    toJsonTree(): {
+        DIDOwner: {
+            id: string;
+            type: string;
+            controller: string;
+            publicKeyBase58: string;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidCreateDidOwnerEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-create-did-owner-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-create-did-owner-event.js
new file mode 100644
index 0000000..fd98c00
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-create-did-owner-event.js
@@ -0,0 +1,66 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidCreateDidOwnerEvent = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const hashing_1 = require("../../../../../utils/hashing");
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidCreateDidOwnerEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id, controller, publicKey) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.DID_OWNER;
+        this.type = HcsDidCreateDidOwnerEvent.KEY_TYPE;
+        if (!id || !controller || !publicKey) {
+            throw new did_error_1.DidError("Validation failed. DID Owner args are missing");
+        }
+        if (!this.isOwnerEventIdValid(id)) {
+            throw new did_error_1.DidError("Event ID is invalid. Expected format: {did}#did-root-key");
+        }
+        this.id = id;
+        this.controller = controller;
+        this.publicKey = publicKey;
+    }
+    getId() {
+        return this.id;
+    }
+    getType() {
+        return this.type;
+    }
+    getController() {
+        return this.controller;
+    }
+    getPublicKey() {
+        return this.publicKey;
+    }
+    getPublicKeyBase58() {
+        return hashing_1.Hashing.base58.encode(this.getPublicKey().toBytes());
+    }
+    getOwnerDef() {
+        return {
+            id: this.getId(),
+            type: this.getType(),
+            controller: this.getController(),
+            publicKeyBase58: this.getPublicKeyBase58(),
+        };
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+                type: this.getType(),
+                controller: this.getController(),
+                publicKeyBase58: this.getPublicKeyBase58(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        const publicKey = sdk_1.PublicKey.fromBytes(hashing_1.Hashing.base58.decode(tree === null || tree === void 0 ? void 0 : tree.publicKeyBase58));
+        return new HcsDidCreateDidOwnerEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.controller, publicKey);
+    }
+}
+exports.HcsDidCreateDidOwnerEvent = HcsDidCreateDidOwnerEvent;
+HcsDidCreateDidOwnerEvent.KEY_TYPE = "Ed25519VerificationKey2018";
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-update-did-owner-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-update-did-owner-event.d.ts
new file mode 100644
index 0000000..139c9ba
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-update-did-owner-event.d.ts
@@ -0,0 +1,4 @@
+import { HcsDidCreateDidOwnerEvent } from "./hcs-did-create-did-owner-event";
+export declare class HcsDidUpdateDidOwnerEvent extends HcsDidCreateDidOwnerEvent {
+    static fromJsonTree(tree: any): HcsDidUpdateDidOwnerEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-update-did-owner-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-update-did-owner-event.js
new file mode 100644
index 0000000..a2e244c
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/owner/hcs-did-update-did-owner-event.js
@@ -0,0 +1,13 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidUpdateDidOwnerEvent = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const hashing_1 = require("../../../../../utils/hashing");
+const hcs_did_create_did_owner_event_1 = require("./hcs-did-create-did-owner-event");
+class HcsDidUpdateDidOwnerEvent extends hcs_did_create_did_owner_event_1.HcsDidCreateDidOwnerEvent {
+    static fromJsonTree(tree) {
+        const publicKey = sdk_1.PublicKey.fromBytes(hashing_1.Hashing.base58.decode(tree === null || tree === void 0 ? void 0 : tree.publicKeyBase58));
+        return new HcsDidUpdateDidOwnerEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.controller, publicKey);
+    }
+}
+exports.HcsDidUpdateDidOwnerEvent = HcsDidUpdateDidOwnerEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-create-service-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-create-service-event.d.ts
new file mode 100644
index 0000000..96f2008
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-create-service-event.d.ts
@@ -0,0 +1,27 @@
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+import { ServiceTypes } from "./types";
+export declare class HcsDidCreateServiceEvent extends HcsDidEvent {
+    readonly targetName = HcsDidEventTargetName.SERVICE;
+    protected id: string;
+    protected type: ServiceTypes;
+    protected serviceEndpoint: string;
+    constructor(id: string, type: ServiceTypes, serviceEndpoint: string);
+    getId(): string;
+    getType(): ServiceTypes;
+    getServiceEndpoint(): string;
+    getServiceDef(): {
+        id: string;
+        type: ServiceTypes;
+        serviceEndpoint: string;
+    };
+    toJsonTree(): {
+        Service: {
+            id: string;
+            type: ServiceTypes;
+            serviceEndpoint: string;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidCreateServiceEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-create-service-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-create-service-event.js
new file mode 100644
index 0000000..54e77e9
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-create-service-event.js
@@ -0,0 +1,53 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidCreateServiceEvent = void 0;
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidCreateServiceEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id, type, serviceEndpoint) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE;
+        if (!id || !type || !serviceEndpoint) {
+            throw new did_error_1.DidError("Validation failed. Services args are missing");
+        }
+        if (!this.isServiceEventIdValid(id)) {
+            throw new did_error_1.DidError("Event ID is invalid. Expected format: {did}#service-{integer}");
+        }
+        this.id = id;
+        this.type = type;
+        this.serviceEndpoint = serviceEndpoint;
+    }
+    getId() {
+        return this.id;
+    }
+    getType() {
+        return this.type;
+    }
+    getServiceEndpoint() {
+        return this.serviceEndpoint;
+    }
+    getServiceDef() {
+        return {
+            id: this.getId(),
+            type: this.getType(),
+            serviceEndpoint: this.getServiceEndpoint(),
+        };
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+                type: this.getType(),
+                serviceEndpoint: this.getServiceEndpoint(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        return new HcsDidCreateServiceEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.type, tree === null || tree === void 0 ? void 0 : tree.serviceEndpoint);
+    }
+}
+exports.HcsDidCreateServiceEvent = HcsDidCreateServiceEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-revoke-service-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-revoke-service-event.d.ts
new file mode 100644
index 0000000..7819b45
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-revoke-service-event.d.ts
@@ -0,0 +1,15 @@
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+export declare class HcsDidRevokeServiceEvent extends HcsDidEvent {
+    readonly targetName = HcsDidEventTargetName.SERVICE;
+    protected id: string;
+    constructor(id: string);
+    getId(): string;
+    toJsonTree(): {
+        Service: {
+            id: string;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidRevokeServiceEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-revoke-service-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-revoke-service-event.js
new file mode 100644
index 0000000..db18ef3
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-revoke-service-event.js
@@ -0,0 +1,36 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidRevokeServiceEvent = void 0;
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidRevokeServiceEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.SERVICE;
+        if (!id) {
+            throw new did_error_1.DidError("Validation failed. Services args are missing");
+        }
+        if (!this.isServiceEventIdValid(id)) {
+            throw new did_error_1.DidError("Event ID is invalid. Expected format: {did}#service-{integer}");
+        }
+        this.id = id;
+    }
+    getId() {
+        return this.id;
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        return new HcsDidRevokeServiceEvent(tree === null || tree === void 0 ? void 0 : tree.id);
+    }
+}
+exports.HcsDidRevokeServiceEvent = HcsDidRevokeServiceEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-update-service-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-update-service-event.d.ts
new file mode 100644
index 0000000..da95312
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-update-service-event.d.ts
@@ -0,0 +1,4 @@
+import { HcsDidCreateServiceEvent } from "./hcs-did-create-service-event";
+export declare class HcsDidUpdateServiceEvent extends HcsDidCreateServiceEvent {
+    static fromJsonTree(tree: any): HcsDidCreateServiceEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-update-service-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-update-service-event.js
new file mode 100644
index 0000000..3ff30f4
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/hcs-did-update-service-event.js
@@ -0,0 +1,10 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidUpdateServiceEvent = void 0;
+const hcs_did_create_service_event_1 = require("./hcs-did-create-service-event");
+class HcsDidUpdateServiceEvent extends hcs_did_create_service_event_1.HcsDidCreateServiceEvent {
+    static fromJsonTree(tree) {
+        return new HcsDidUpdateServiceEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.type, tree === null || tree === void 0 ? void 0 : tree.serviceEndpoint);
+    }
+}
+exports.HcsDidUpdateServiceEvent = HcsDidUpdateServiceEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/types.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/types.d.ts
new file mode 100644
index 0000000..88541bc
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/types.d.ts
@@ -0,0 +1 @@
+export declare type ServiceTypes = "LinkedDomains" | "DIDCommMessaging";
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/types.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/types.js
new file mode 100644
index 0000000..c8ad2e5
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/service/types.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event.d.ts
new file mode 100644
index 0000000..6eb087b
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event.d.ts
@@ -0,0 +1,33 @@
+import { PublicKey } from "@hashgraph/sdk";
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+import { VerificationMethodSupportedKeyType } from "./types";
+export declare class HcsDidCreateVerificationMethodEvent extends HcsDidEvent {
+    readonly targetName = HcsDidEventTargetName.VERIFICATION_METHOD;
+    protected id: string;
+    protected type: VerificationMethodSupportedKeyType;
+    protected controller: string;
+    protected publicKey: PublicKey;
+    constructor(id: string, type: VerificationMethodSupportedKeyType, controller: string, publicKey: PublicKey);
+    getId(): string;
+    getType(): "Ed25519VerificationKey2018";
+    getController(): string;
+    getPublicKey(): PublicKey;
+    getPublicKeyBase58(): string;
+    getVerificationMethodDef(): {
+        id: string;
+        type: "Ed25519VerificationKey2018";
+        controller: string;
+        publicKeyBase58: string;
+    };
+    toJsonTree(): {
+        VerificationMethod: {
+            id: string;
+            type: "Ed25519VerificationKey2018";
+            controller: string;
+            publicKeyBase58: string;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidCreateVerificationMethodEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event.js
new file mode 100644
index 0000000..0561d3c
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event.js
@@ -0,0 +1,65 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidCreateVerificationMethodEvent = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const hashing_1 = require("../../../../../utils/hashing");
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidCreateVerificationMethodEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id, type, controller, publicKey) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD;
+        if (!id || !type || !controller || !publicKey) {
+            throw new did_error_1.DidError("Validation failed. Verification Method args are missing");
+        }
+        if (!this.isKeyEventIdValid(id)) {
+            throw new did_error_1.DidError("Event ID is invalid. Expected format: {did}#key-{integer}");
+        }
+        this.id = id;
+        this.type = type;
+        this.controller = controller;
+        this.publicKey = publicKey;
+    }
+    getId() {
+        return this.id;
+    }
+    getType() {
+        return this.type;
+    }
+    getController() {
+        return this.controller;
+    }
+    getPublicKey() {
+        return this.publicKey;
+    }
+    getPublicKeyBase58() {
+        return hashing_1.Hashing.base58.encode(this.getPublicKey().toBytes());
+    }
+    getVerificationMethodDef() {
+        return {
+            id: this.getId(),
+            type: this.getType(),
+            controller: this.getController(),
+            publicKeyBase58: this.getPublicKeyBase58(),
+        };
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+                type: this.getType(),
+                controller: this.getController(),
+                publicKeyBase58: this.getPublicKeyBase58(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        const publicKey = sdk_1.PublicKey.fromBytes(hashing_1.Hashing.base58.decode(tree === null || tree === void 0 ? void 0 : tree.publicKeyBase58));
+        return new HcsDidCreateVerificationMethodEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.type, tree === null || tree === void 0 ? void 0 : tree.controller, publicKey);
+    }
+}
+exports.HcsDidCreateVerificationMethodEvent = HcsDidCreateVerificationMethodEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event.d.ts
new file mode 100644
index 0000000..7405f72
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event.d.ts
@@ -0,0 +1,15 @@
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+export declare class HcsDidRevokeVerificationMethodEvent extends HcsDidEvent {
+    readonly targetName = HcsDidEventTargetName.VERIFICATION_METHOD;
+    protected id: string;
+    constructor(id: string);
+    getId(): string;
+    toJsonTree(): {
+        VerificationMethod: {
+            id: string;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidRevokeVerificationMethodEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event.js
new file mode 100644
index 0000000..fdb09ae
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event.js
@@ -0,0 +1,36 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidRevokeVerificationMethodEvent = void 0;
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidRevokeVerificationMethodEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_METHOD;
+        if (!id) {
+            throw new did_error_1.DidError("Validation failed. Verification Method args are missing");
+        }
+        if (!this.isKeyEventIdValid(id)) {
+            throw new did_error_1.DidError("Event ID is invalid. Expected format: {did}#key-{integer}");
+        }
+        this.id = id;
+    }
+    getId() {
+        return this.id;
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        return new HcsDidRevokeVerificationMethodEvent(tree === null || tree === void 0 ? void 0 : tree.id);
+    }
+}
+exports.HcsDidRevokeVerificationMethodEvent = HcsDidRevokeVerificationMethodEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event.d.ts
new file mode 100644
index 0000000..3ca6de8
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event.d.ts
@@ -0,0 +1,4 @@
+import { HcsDidCreateVerificationMethodEvent } from "./hcs-did-create-verification-method-event";
+export declare class HcsDidUpdateVerificationMethodEvent extends HcsDidCreateVerificationMethodEvent {
+    static fromJsonTree(tree: any): HcsDidCreateVerificationMethodEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event.js
new file mode 100644
index 0000000..8fa72ad
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event.js
@@ -0,0 +1,13 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidUpdateVerificationMethodEvent = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const hashing_1 = require("../../../../../utils/hashing");
+const hcs_did_create_verification_method_event_1 = require("./hcs-did-create-verification-method-event");
+class HcsDidUpdateVerificationMethodEvent extends hcs_did_create_verification_method_event_1.HcsDidCreateVerificationMethodEvent {
+    static fromJsonTree(tree) {
+        const publicKey = sdk_1.PublicKey.fromBytes(hashing_1.Hashing.base58.decode(tree === null || tree === void 0 ? void 0 : tree.publicKeyBase58));
+        return new HcsDidUpdateVerificationMethodEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.type, tree === null || tree === void 0 ? void 0 : tree.controller, publicKey);
+    }
+}
+exports.HcsDidUpdateVerificationMethodEvent = HcsDidUpdateVerificationMethodEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/types.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/types.d.ts
new file mode 100644
index 0000000..416a123
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/types.d.ts
@@ -0,0 +1 @@
+export declare type VerificationMethodSupportedKeyType = "Ed25519VerificationKey2018";
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/types.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/types.js
new file mode 100644
index 0000000..c8ad2e5
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-method/types.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event.d.ts
new file mode 100644
index 0000000..3027150
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event.d.ts
@@ -0,0 +1,36 @@
+import { PublicKey } from "@hashgraph/sdk";
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+import { VerificationRelationshipSupportedKeyType, VerificationRelationshipType } from "./types";
+export declare class HcsDidCreateVerificationRelationshipEvent extends HcsDidEvent {
+    readonly targetName = HcsDidEventTargetName.VERIFICATION_RELATIONSHIP;
+    protected id: string;
+    protected type: VerificationRelationshipSupportedKeyType;
+    protected relationshipType: VerificationRelationshipType;
+    protected controller: string;
+    protected publicKey: PublicKey;
+    constructor(id: string, relationshipType: VerificationRelationshipType, type: VerificationRelationshipSupportedKeyType, controller: string, publicKey: PublicKey);
+    getId(): string;
+    getType(): "Ed25519VerificationKey2018";
+    getRelationshipType(): VerificationRelationshipType;
+    getController(): string;
+    getPublicKey(): PublicKey;
+    getPublicKeyBase58(): string;
+    getVerificationMethodDef(): {
+        id: string;
+        type: "Ed25519VerificationKey2018";
+        controller: string;
+        publicKeyBase58: string;
+    };
+    toJsonTree(): {
+        VerificationRelationship: {
+            id: string;
+            relationshipType: VerificationRelationshipType;
+            type: "Ed25519VerificationKey2018";
+            controller: string;
+            publicKeyBase58: string;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidCreateVerificationRelationshipEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event.js
new file mode 100644
index 0000000..70ec746
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event.js
@@ -0,0 +1,71 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidCreateVerificationRelationshipEvent = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const hashing_1 = require("../../../../../utils/hashing");
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidCreateVerificationRelationshipEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id, relationshipType, type, controller, publicKey) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP;
+        this.type = "Ed25519VerificationKey2018";
+        if (!id || !relationshipType || !type || !controller || !publicKey) {
+            throw new did_error_1.DidError("Validation failed. Verification Relationship args are missing");
+        }
+        if (!this.isKeyEventIdValid(id)) {
+            throw new did_error_1.DidError("Event ID is invalid. Expected format: {did}#key-{integer}");
+        }
+        this.id = id;
+        this.type = type;
+        this.relationshipType = relationshipType;
+        this.controller = controller;
+        this.publicKey = publicKey;
+    }
+    getId() {
+        return this.id;
+    }
+    getType() {
+        return this.type;
+    }
+    getRelationshipType() {
+        return this.relationshipType;
+    }
+    getController() {
+        return this.controller;
+    }
+    getPublicKey() {
+        return this.publicKey;
+    }
+    getPublicKeyBase58() {
+        return hashing_1.Hashing.base58.encode(this.getPublicKey().toBytes());
+    }
+    getVerificationMethodDef() {
+        return {
+            id: this.getId(),
+            type: this.getType(),
+            controller: this.getController(),
+            publicKeyBase58: this.getPublicKeyBase58(),
+        };
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+                relationshipType: this.getRelationshipType(),
+                type: this.getType(),
+                controller: this.getController(),
+                publicKeyBase58: this.getPublicKeyBase58(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        const publicKey = sdk_1.PublicKey.fromBytes(hashing_1.Hashing.base58.decode(tree === null || tree === void 0 ? void 0 : tree.publicKeyBase58));
+        return new HcsDidCreateVerificationRelationshipEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.relationshipType, tree === null || tree === void 0 ? void 0 : tree.type, tree === null || tree === void 0 ? void 0 : tree.controller, publicKey);
+    }
+}
+exports.HcsDidCreateVerificationRelationshipEvent = HcsDidCreateVerificationRelationshipEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event.d.ts
new file mode 100644
index 0000000..35549b5
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event.d.ts
@@ -0,0 +1,19 @@
+import { HcsDidEvent } from "../hcs-did-event";
+import { HcsDidEventTargetName } from "../hcs-did-event-target-name";
+import { VerificationRelationshipType } from "./types";
+export declare class HcsDidRevokeVerificationRelationshipEvent extends HcsDidEvent {
+    readonly targetName = HcsDidEventTargetName.VERIFICATION_RELATIONSHIP;
+    protected id: string;
+    protected relationshipType: VerificationRelationshipType;
+    constructor(id: string, relationshipType: VerificationRelationshipType);
+    getId(): string;
+    getRelationshipType(): VerificationRelationshipType;
+    toJsonTree(): {
+        VerificationRelationship: {
+            id: string;
+            relationshipType: VerificationRelationshipType;
+        };
+    };
+    toJSON(): string;
+    static fromJsonTree(tree: any): HcsDidRevokeVerificationRelationshipEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event.js
new file mode 100644
index 0000000..8408d03
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event.js
@@ -0,0 +1,41 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidRevokeVerificationRelationshipEvent = void 0;
+const did_error_1 = require("../../../../did-error");
+const hcs_did_event_1 = require("../hcs-did-event");
+const hcs_did_event_target_name_1 = require("../hcs-did-event-target-name");
+class HcsDidRevokeVerificationRelationshipEvent extends hcs_did_event_1.HcsDidEvent {
+    constructor(id, relationshipType) {
+        super();
+        this.targetName = hcs_did_event_target_name_1.HcsDidEventTargetName.VERIFICATION_RELATIONSHIP;
+        if (!id || !relationshipType) {
+            throw new did_error_1.DidError("Validation failed. Verification Relationship args are missing");
+        }
+        if (!this.isKeyEventIdValid(id)) {
+            throw new did_error_1.DidError("Event ID is invalid. Expected format: {did}#key-{integer}");
+        }
+        this.id = id;
+        this.relationshipType = relationshipType;
+    }
+    getId() {
+        return this.id;
+    }
+    getRelationshipType() {
+        return this.relationshipType;
+    }
+    toJsonTree() {
+        return {
+            [this.targetName]: {
+                id: this.getId(),
+                relationshipType: this.getRelationshipType(),
+            },
+        };
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJsonTree(tree) {
+        return new HcsDidRevokeVerificationRelationshipEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.relationshipType);
+    }
+}
+exports.HcsDidRevokeVerificationRelationshipEvent = HcsDidRevokeVerificationRelationshipEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event.d.ts
new file mode 100644
index 0000000..72c89c3
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event.d.ts
@@ -0,0 +1,4 @@
+import { HcsDidCreateVerificationRelationshipEvent } from "./hcs-did-create-verification-relationship-event";
+export declare class HcsDidUpdateVerificationRelationshipEvent extends HcsDidCreateVerificationRelationshipEvent {
+    static fromJsonTree(tree: any): HcsDidUpdateVerificationRelationshipEvent;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event.js
new file mode 100644
index 0000000..7880ac0
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event.js
@@ -0,0 +1,13 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidUpdateVerificationRelationshipEvent = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const hashing_1 = require("../../../../../utils/hashing");
+const hcs_did_create_verification_relationship_event_1 = require("./hcs-did-create-verification-relationship-event");
+class HcsDidUpdateVerificationRelationshipEvent extends hcs_did_create_verification_relationship_event_1.HcsDidCreateVerificationRelationshipEvent {
+    static fromJsonTree(tree) {
+        const publicKey = sdk_1.PublicKey.fromBytes(hashing_1.Hashing.base58.decode(tree === null || tree === void 0 ? void 0 : tree.publicKeyBase58));
+        return new HcsDidUpdateVerificationRelationshipEvent(tree === null || tree === void 0 ? void 0 : tree.id, tree === null || tree === void 0 ? void 0 : tree.relationshipType, tree === null || tree === void 0 ? void 0 : tree.type, tree === null || tree === void 0 ? void 0 : tree.controller, publicKey);
+    }
+}
+exports.HcsDidUpdateVerificationRelationshipEvent = HcsDidUpdateVerificationRelationshipEvent;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/types.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/types.d.ts
new file mode 100644
index 0000000..dd74dd3
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/types.d.ts
@@ -0,0 +1,2 @@
+export declare type VerificationRelationshipType = "authentication" | "assertionMethod" | "keyAgreement" | "capabilityInvocation" | "capabilityDelegation";
+export declare type VerificationRelationshipSupportedKeyType = "Ed25519VerificationKey2018";
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/types.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/types.js
new file mode 100644
index 0000000..c8ad2e5
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/event/verification-relationship/types.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-event-message-resolver.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-event-message-resolver.d.ts
new file mode 100644
index 0000000..80c9540
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-event-message-resolver.d.ts
@@ -0,0 +1,71 @@
+import { Client, Timestamp, TopicId } from "@hashgraph/sdk";
+import Long from "long";
+import { Validator } from "../../../utils/validator";
+import { MessageEnvelope } from "../message-envelope";
+import { HcsDidMessage } from "./hcs-did-message";
+/**
+ * Resolves the DID Events from Hedera network.
+ */
+export declare class HcsDidEventMessageResolver {
+    /**
+     * Default time to wait before finishing resolution and after the last message was received.
+     */
+    static DEFAULT_TIMEOUT: Long;
+    protected topicId: TopicId;
+    protected messages: MessageEnvelope<HcsDidMessage>[];
+    private lastMessageArrivalTime;
+    private nextMessageArrivalTimeout;
+    private resultsHandler;
+    private errorHandler;
+    private existingSignatures;
+    private readonly listener;
+    private noMoreMessagesTimeout;
+    /**
+     * Instantiates a new DID resolver for the given DID topic.
+     *
+     * @param topicId The HCS DID topic ID.
+     */
+    constructor(topicId: TopicId, startTime?: Timestamp);
+    execute(client: Client): void;
+    /**
+     * Handles incoming DID messages from DID Topic on a mirror node.
+     *
+     * @param envelope The parsed message envelope in a PLAIN mode.
+     */
+    private handleMessage;
+    /**
+     * Waits for a new message from the topic for the configured amount of time.
+     */
+    protected waitOrFinish(): Promise<void>;
+    protected finish(): Promise<void>;
+    /**
+     * Defines a handler for resolution results.
+     * This will be called when the resolution process is finished.
+     *
+     * @param handler The results handler.
+     * @return This resolver instance.
+     */
+    whenFinished(handler: (input: MessageEnvelope<HcsDidMessage>[]) => void): HcsDidEventMessageResolver;
+    /**
+     * Defines a handler for errors when they happen during resolution.
+     *
+     * @param handler The error handler.
+     * @return This resolver instance.
+     */
+    onError(handler: (input: Error) => void): HcsDidEventMessageResolver;
+    /**
+     * Defines a maximum time in milliseconds to wait for new messages from the topic.
+     * Default is 30 seconds.
+     *
+     * @param timeout The timeout in milliseconds to wait for new messages from the topic.
+     * @return This resolver instance.
+     */
+    setTimeout(timeout: Long | number): HcsDidEventMessageResolver;
+    /**
+     * Runs validation logic of the resolver's configuration.
+     *
+     * @param validator The errors validator.
+     */
+    protected validate(validator: Validator): void;
+    protected matchesSearchCriteria(message: HcsDidMessage): boolean;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-event-message-resolver.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-event-message-resolver.js
new file mode 100644
index 0000000..0d9019c
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-event-message-resolver.js
@@ -0,0 +1,144 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidEventMessageResolver = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const long_1 = __importDefault(require("long"));
+const validator_1 = require("../../../utils/validator");
+const hcs_did_topic_listener_1 = require("./hcs-did-topic-listener");
+/**
+ * Resolves the DID Events from Hedera network.
+ */
+class HcsDidEventMessageResolver {
+    /**
+     * Instantiates a new DID resolver for the given DID topic.
+     *
+     * @param topicId The HCS DID topic ID.
+     */
+    constructor(topicId, startTime = new sdk_1.Timestamp(0, 0)) {
+        this.messages = [];
+        this.topicId = topicId;
+        this.listener = new hcs_did_topic_listener_1.HcsDidTopicListener(this.topicId, startTime);
+        this.noMoreMessagesTimeout = HcsDidEventMessageResolver.DEFAULT_TIMEOUT;
+        this.lastMessageArrivalTime = long_1.default.fromInt(Date.now());
+    }
+    execute(client) {
+        new validator_1.Validator().checkValidationErrors("Resolver not executed: ", (v) => {
+            return this.validate(v);
+        });
+        this.existingSignatures = [];
+        this.listener
+            .setEndTime(sdk_1.Timestamp.fromDate(new Date()))
+            .setIgnoreErrors(false)
+            .onError(this.errorHandler)
+            .onComplete(() => this.finish())
+            .subscribe(client, (msg) => {
+            return this.handleMessage(msg);
+        });
+        this.lastMessageArrivalTime = long_1.default.fromInt(Date.now());
+        this.waitOrFinish();
+    }
+    /**
+     * Handles incoming DID messages from DID Topic on a mirror node.
+     *
+     * @param envelope The parsed message envelope in a PLAIN mode.
+     */
+    handleMessage(envelope) {
+        this.lastMessageArrivalTime = long_1.default.fromInt(Date.now());
+        if (!this.matchesSearchCriteria(envelope.open())) {
+            return;
+        }
+        if (this.existingSignatures.indexOf(envelope.getSignature()) != -1) {
+            return;
+        }
+        this.existingSignatures.push(envelope.getSignature());
+        this.messages.push(envelope);
+    }
+    /**
+     * Waits for a new message from the topic for the configured amount of time.
+     */
+    waitOrFinish() {
+        return __awaiter(this, void 0, void 0, function* () {
+            const timeDiff = long_1.default.fromInt(Date.now()).sub(this.lastMessageArrivalTime);
+            if (timeDiff.lessThanOrEqual(this.noMoreMessagesTimeout)) {
+                if (this.nextMessageArrivalTimeout) {
+                    clearTimeout(this.nextMessageArrivalTimeout);
+                }
+                this.nextMessageArrivalTimeout = setTimeout(() => this.waitOrFinish(), this.noMoreMessagesTimeout.sub(timeDiff).toNumber());
+                return;
+            }
+            yield this.finish();
+        });
+    }
+    finish() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.resultsHandler(this.messages);
+            if (this.nextMessageArrivalTimeout) {
+                clearTimeout(this.nextMessageArrivalTimeout);
+            }
+            if (this.listener) {
+                this.listener.unsubscribe();
+            }
+        });
+    }
+    /**
+     * Defines a handler for resolution results.
+     * This will be called when the resolution process is finished.
+     *
+     * @param handler The results handler.
+     * @return This resolver instance.
+     */
+    whenFinished(handler) {
+        this.resultsHandler = handler;
+        return this;
+    }
+    /**
+     * Defines a handler for errors when they happen during resolution.
+     *
+     * @param handler The error handler.
+     * @return This resolver instance.
+     */
+    onError(handler) {
+        this.errorHandler = handler;
+        return this;
+    }
+    /**
+     * Defines a maximum time in milliseconds to wait for new messages from the topic.
+     * Default is 30 seconds.
+     *
+     * @param timeout The timeout in milliseconds to wait for new messages from the topic.
+     * @return This resolver instance.
+     */
+    setTimeout(timeout) {
+        this.noMoreMessagesTimeout = long_1.default.fromValue(timeout);
+        return this;
+    }
+    /**
+     * Runs validation logic of the resolver's configuration.
+     *
+     * @param validator The errors validator.
+     */
+    validate(validator) {
+        validator.require(!!this.topicId, "Consensus topic ID not defined.");
+        validator.require(!!this.resultsHandler, "Results handler 'whenFinished' not defined.");
+    }
+    matchesSearchCriteria(message) {
+        return true;
+    }
+}
+exports.HcsDidEventMessageResolver = HcsDidEventMessageResolver;
+/**
+ * Default time to wait before finishing resolution and after the last message was received.
+ */
+HcsDidEventMessageResolver.DEFAULT_TIMEOUT = long_1.default.fromInt(30000);
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-message.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-message.d.ts
new file mode 100644
index 0000000..90b9cf8
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-message.d.ts
@@ -0,0 +1,39 @@
+import { Timestamp, TopicId } from "@hashgraph/sdk";
+import { DidMethodOperation } from "../../did-method-operation";
+import { HcsDidEvent } from "./event/hcs-did-event";
+export declare type Signer<T> = (message: T) => T;
+/**
+ * The DID document message submitted to appnet's DID Topic.
+ */
+export declare class HcsDidMessage {
+    private static serialVersionUID;
+    protected timestamp: Timestamp;
+    protected operation: DidMethodOperation;
+    protected did: string;
+    protected event: HcsDidEvent;
+    /**
+     * Creates a new instance of {@link HcsDidMessage}.
+     *
+     * @param operation         The operation on DID document.
+     * @param did               The DID string.
+     * @param event             The DID Event.
+     */
+    constructor(operation: DidMethodOperation, did: string, event: HcsDidEvent);
+    getTimestamp(): Timestamp;
+    getOperation(): DidMethodOperation;
+    getDid(): string;
+    getEvent(): HcsDidEvent;
+    getEventBase64(): string;
+    /**
+     * Validates this DID message by checking its completeness, signature and DID document.
+     *
+     * @param didTopicId The DID topic ID against which the message is validated.
+     * @return True if the message is valid, false otherwise.
+     */
+    isValid(): boolean;
+    isValid(didTopicId: TopicId): boolean;
+    toJsonTree(): any;
+    static fromJsonTree(tree: any, result?: HcsDidMessage): HcsDidMessage;
+    toJSON(): string;
+    static fromJson(json: string): HcsDidMessage;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-message.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-message.js
new file mode 100644
index 0000000..1e0713a
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-message.js
@@ -0,0 +1,88 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidMessage = void 0;
+const long_1 = __importDefault(require("long"));
+const timestamp_utils_1 = require("../../../utils/timestamp-utils");
+const did_parser_1 = require("../../did-parser");
+const hcs_did_event_parser_1 = require("./event/hcs-did-event-parser");
+/**
+ * The DID document message submitted to appnet's DID Topic.
+ */
+class HcsDidMessage {
+    /**
+     * Creates a new instance of {@link HcsDidMessage}.
+     *
+     * @param operation         The operation on DID document.
+     * @param did               The DID string.
+     * @param event             The DID Event.
+     */
+    constructor(operation, did, event) {
+        this.timestamp = timestamp_utils_1.TimestampUtils.now();
+        this.operation = operation;
+        this.did = did;
+        this.event = event;
+    }
+    getTimestamp() {
+        return this.timestamp;
+    }
+    getOperation() {
+        return this.operation;
+    }
+    getDid() {
+        return this.did;
+    }
+    getEvent() {
+        return this.event;
+    }
+    getEventBase64() {
+        return this.getEvent().getBase64();
+    }
+    isValid(...args) {
+        const didTopicId = args[0] || null;
+        if (this.did == null || this.event == null || this.operation == null) {
+            return false;
+        }
+        try {
+            const hcsDid = did_parser_1.DidParser.parse(this.did);
+            // Verify that the message was sent to the right topic, if the DID contains the topic
+            if (!!didTopicId && !!hcsDid.getTopicId() && didTopicId.toString() != hcsDid.getTopicId().toString()) {
+                return false;
+            }
+        }
+        catch (e) {
+            return false;
+        }
+        return true;
+    }
+    toJsonTree() {
+        const result = { timestamp: timestamp_utils_1.TimestampUtils.toJSON(this.timestamp) };
+        result.operation = this.operation;
+        result.did = this.did;
+        result.event = this.getEventBase64();
+        return result;
+    }
+    static fromJsonTree(tree, result) {
+        const event = hcs_did_event_parser_1.HcsDidEventParser.fromBase64(tree.operation, tree.event);
+        if (!result) {
+            result = new HcsDidMessage(tree.operation, tree.did, event);
+        }
+        else {
+            result.operation = tree.operation;
+            result.did = tree.did;
+            result.event = event;
+        }
+        result.timestamp = timestamp_utils_1.TimestampUtils.fromJson(tree.timestamp);
+        return result;
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    static fromJson(json) {
+        return HcsDidMessage.fromJsonTree(JSON.parse(json));
+    }
+}
+exports.HcsDidMessage = HcsDidMessage;
+HcsDidMessage.serialVersionUID = long_1.default.fromInt(1);
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-topic-listener.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-topic-listener.d.ts
new file mode 100644
index 0000000..d8588a8
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-topic-listener.d.ts
@@ -0,0 +1,105 @@
+/// <reference types="long" />
+import { Client, Timestamp, TopicId, TopicMessage, TopicMessageQuery } from "@hashgraph/sdk";
+import SubscriptionHandle from "@hashgraph/sdk/lib/topic/SubscriptionHandle";
+import { MessageEnvelope } from "../message-envelope";
+import { HcsDidMessage } from "./hcs-did-message";
+/**
+ * A listener of confirmed {@link HcsDidMessage} messages from a DID topic.
+ * Messages are received from a given mirror node, parsed and validated.
+ */
+export declare class HcsDidTopicListener {
+    protected topicId: TopicId;
+    protected query: TopicMessageQuery;
+    protected errorHandler: (input: Error) => void;
+    protected ignoreErrors: boolean;
+    protected subscriptionHandle: SubscriptionHandle;
+    protected filters: ((input: TopicMessage) => boolean)[];
+    protected invalidMessageHandler: (t: TopicMessage, u: string) => void;
+    /**
+     * Creates a new instance of a DID topic listener for the given consensus topic.
+     * By default, invalid messages are ignored and errors are not.
+     *
+     * @param didTopicId The DID consensus topic ID.
+     */
+    constructor(topicId: TopicId, startTime?: Timestamp);
+    /**
+     * Adds a custom filter for topic responses from a mirror node.
+     * Messages that do not pass the test are skipped before any other checks are run.
+     *
+     * @param filter The filter function.
+     * @return This listener instance.
+     */
+    addFilter(filter: (input: TopicMessage) => boolean): HcsDidTopicListener;
+    /**
+     * Subscribes to mirror node topic messages stream.
+     *
+     * @param client   Mirror client instance.
+     * @param receiver Receiver of parsed messages.
+     * @return This listener instance.
+     */
+    subscribe(client: Client, receiver: (input: MessageEnvelope<HcsDidMessage>) => void): HcsDidTopicListener;
+    /**
+     * Stops receiving messages from the topic.
+     */
+    unsubscribe(): void;
+    /**
+     * Handles incoming messages from the topic on a mirror node.
+     *
+     * @param response Response message coming from the mirror node for the topic.
+     * @param receiver Consumer of the result message.
+     */
+    protected handleResponse(response: TopicMessage, receiver: (input: MessageEnvelope<HcsDidMessage>) => void): void;
+    /**
+     * Extracts and parses the message inside the response object into the given type.
+     *
+     * @param response Response message coming from the mirror node for this listener's topic.
+     * @return The message inside an envelope.
+     */
+    protected extractMessage(response: TopicMessage): MessageEnvelope<HcsDidMessage>;
+    /**
+     * Validates the message and its envelope signature.
+     *
+     * @param message  The message inside an envelope.
+     * @param response Response message coming from the mirror node for this listener's topic.
+     * @return True if the message is valid, False otherwise.
+     */
+    protected isMessageValid(envelope: MessageEnvelope<HcsDidMessage>, response: TopicMessage): boolean;
+    /**
+     * Handles the given error internally.
+     * If external error handler is defined, passes the error there, otherwise raises RuntimeException or ignores it
+     * depending on a ignoreErrors flag.
+     *
+     * @param err The error.
+     * @throws RuntimeException Runtime exception with the given error in case external error handler is not defined
+     *                          and errors were not requested to be ignored.
+     */
+    protected handleError(err: Error): void;
+    /**
+     * Reports invalid message to the handler.
+     *
+     * @param response The mirror response.
+     * @param reason   The reason why message validation failed.
+     */
+    protected reportInvalidMessage(response: TopicMessage, reason: string): void;
+    /**
+     * Defines a handler for errors when they happen during execution.
+     *
+     * @param handler The error handler.
+     * @return This transaction instance.
+     */
+    onError(handler: (input: Error) => void): HcsDidTopicListener;
+    /**
+     * Defines a handler for invalid messages received from the topic.
+     * The first parameter of the handler is the mirror response.
+     * The second parameter is the reason why the message failed validation (if available).
+     *
+     * @param handler The invalid message handler.
+     * @return This transaction instance.
+     */
+    onInvalidMessageReceived(handler: (t: TopicMessage, u: string) => void): HcsDidTopicListener;
+    setStartTime(startTime: Timestamp): HcsDidTopicListener;
+    setEndTime(endTime: Timestamp): HcsDidTopicListener;
+    setLimit(messagesLimit: Long): HcsDidTopicListener;
+    setIgnoreErrors(ignoreErrors: boolean): HcsDidTopicListener;
+    onComplete(handler: () => void): this;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-topic-listener.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-topic-listener.js
new file mode 100644
index 0000000..907136b
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-topic-listener.js
@@ -0,0 +1,202 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidTopicListener = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const did_error_1 = require("../../did-error");
+const message_envelope_1 = require("../message-envelope");
+const hcs_did_message_1 = require("./hcs-did-message");
+/**
+ * A listener of confirmed {@link HcsDidMessage} messages from a DID topic.
+ * Messages are received from a given mirror node, parsed and validated.
+ */
+class HcsDidTopicListener {
+    /**
+     * Creates a new instance of a DID topic listener for the given consensus topic.
+     * By default, invalid messages are ignored and errors are not.
+     *
+     * @param didTopicId The DID consensus topic ID.
+     */
+    constructor(topicId, startTime = new sdk_1.Timestamp(0, 0)) {
+        this.topicId = topicId;
+        this.query = new sdk_1.TopicMessageQuery().setTopicId(topicId).setStartTime(startTime);
+        this.query.setMaxBackoff(2000);
+        this.query.setMaxAttempts(15);
+        this.ignoreErrors = false;
+    }
+    /**
+     * Adds a custom filter for topic responses from a mirror node.
+     * Messages that do not pass the test are skipped before any other checks are run.
+     *
+     * @param filter The filter function.
+     * @return This listener instance.
+     */
+    addFilter(filter) {
+        if (!this.filters) {
+            this.filters = [];
+        }
+        this.filters.push(filter);
+        return this;
+    }
+    /**
+     * Subscribes to mirror node topic messages stream.
+     *
+     * @param client   Mirror client instance.
+     * @param receiver Receiver of parsed messages.
+     * @return This listener instance.
+     */
+    subscribe(client, receiver) {
+        const errorHandler = (message, error) => {
+            this.handleError(error);
+        };
+        const listener = (message) => {
+            this.handleResponse(message, receiver);
+        };
+        this.subscriptionHandle = this.query.subscribe(client, errorHandler, listener);
+        return this;
+    }
+    /**
+     * Stops receiving messages from the topic.
+     */
+    unsubscribe() {
+        if (this.subscriptionHandle) {
+            this.subscriptionHandle.unsubscribe();
+        }
+    }
+    /**
+     * Handles incoming messages from the topic on a mirror node.
+     *
+     * @param response Response message coming from the mirror node for the topic.
+     * @param receiver Consumer of the result message.
+     */
+    handleResponse(response, receiver) {
+        if (this.filters) {
+            for (let filter of this.filters) {
+                if (!filter(response)) {
+                    this.reportInvalidMessage(response, "Message was rejected by external filter");
+                    return;
+                }
+            }
+        }
+        const envelope = this.extractMessage(response);
+        if (!envelope) {
+            this.reportInvalidMessage(response, "Extracting envelope from the mirror response failed");
+            return;
+        }
+        if (this.isMessageValid(envelope, response)) {
+            receiver(envelope);
+        }
+    }
+    /**
+     * Extracts and parses the message inside the response object into the given type.
+     *
+     * @param response Response message coming from the mirror node for this listener's topic.
+     * @return The message inside an envelope.
+     */
+    extractMessage(response) {
+        let result = null;
+        try {
+            result = message_envelope_1.MessageEnvelope.fromMirrorResponse(response, hcs_did_message_1.HcsDidMessage);
+        }
+        catch (err) {
+            this.handleError(err);
+        }
+        return result;
+    }
+    /**
+     * Validates the message and its envelope signature.
+     *
+     * @param message  The message inside an envelope.
+     * @param response Response message coming from the mirror node for this listener's topic.
+     * @return True if the message is valid, False otherwise.
+     */
+    isMessageValid(envelope, response) {
+        try {
+            const message = envelope.open();
+            if (!message) {
+                this.reportInvalidMessage(response, "Empty message received when opening envelope");
+                return false;
+            }
+            if (!message.isValid(this.topicId)) {
+                this.reportInvalidMessage(response, "Message content validation failed.");
+                return false;
+            }
+            return true;
+        }
+        catch (err) {
+            this.handleError(err);
+            this.reportInvalidMessage(response, "Exception while validating message: " + err.message);
+            return false;
+        }
+    }
+    /**
+     * Handles the given error internally.
+     * If external error handler is defined, passes the error there, otherwise raises RuntimeException or ignores it
+     * depending on a ignoreErrors flag.
+     *
+     * @param err The error.
+     * @throws RuntimeException Runtime exception with the given error in case external error handler is not defined
+     *                          and errors were not requested to be ignored.
+     */
+    handleError(err) {
+        if (this.errorHandler) {
+            this.errorHandler(err);
+        }
+        else if (!this.ignoreErrors) {
+            throw new did_error_1.DidError(err.message);
+        }
+    }
+    /**
+     * Reports invalid message to the handler.
+     *
+     * @param response The mirror response.
+     * @param reason   The reason why message validation failed.
+     */
+    reportInvalidMessage(response, reason) {
+        if (this.invalidMessageHandler) {
+            this.invalidMessageHandler(response, reason);
+        }
+    }
+    /**
+     * Defines a handler for errors when they happen during execution.
+     *
+     * @param handler The error handler.
+     * @return This transaction instance.
+     */
+    onError(handler) {
+        this.errorHandler = handler;
+        return this;
+    }
+    /**
+     * Defines a handler for invalid messages received from the topic.
+     * The first parameter of the handler is the mirror response.
+     * The second parameter is the reason why the message failed validation (if available).
+     *
+     * @param handler The invalid message handler.
+     * @return This transaction instance.
+     */
+    onInvalidMessageReceived(handler) {
+        this.invalidMessageHandler = handler;
+        return this;
+    }
+    setStartTime(startTime) {
+        this.query.setStartTime(startTime);
+        return this;
+    }
+    setEndTime(endTime) {
+        this.query.setEndTime(endTime);
+        return this;
+    }
+    setLimit(messagesLimit) {
+        this.query.setLimit(messagesLimit);
+        return this;
+    }
+    setIgnoreErrors(ignoreErrors) {
+        this.ignoreErrors = ignoreErrors;
+        return this;
+    }
+    onComplete(handler) {
+        this.query.setCompletionHandler(handler);
+        return this;
+    }
+}
+exports.HcsDidTopicListener = HcsDidTopicListener;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-transaction.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-transaction.d.ts
new file mode 100644
index 0000000..3bb1b70
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-transaction.d.ts
@@ -0,0 +1,84 @@
+import { Client, TopicId, TopicMessageSubmitTransaction, Transaction, TransactionId } from "@hashgraph/sdk";
+import { Validator } from "../../../utils/validator";
+import { MessageEnvelope } from "../message-envelope";
+import { HcsDidMessage, Signer } from "./hcs-did-message";
+import { HcsDidTopicListener } from "./hcs-did-topic-listener";
+/**
+ * The DID document creation, update or deletion transaction.
+ * Builds a correct {@link HcsDidMessage} and send it to HCS DID topic.
+ */
+export declare class HcsDidTransaction {
+    private static SUBTRACT_TIME;
+    protected topicId: TopicId;
+    protected message: MessageEnvelope<HcsDidMessage>;
+    private buildTransactionFunction;
+    private receiver;
+    private errorHandler;
+    private executed;
+    private signer;
+    private listener;
+    /**
+     * Instantiates a new transaction object from a message that was already prepared.
+     *
+     * @param topicId The HCS DID topic ID where message will be submitted.
+     * @param message The message envelope.
+     */
+    constructor(message: MessageEnvelope<HcsDidMessage>, topicId: TopicId);
+    /**
+     * Provides a {@link MessageListener} instance specific to the submitted message type.
+     *
+     * @param topicIdToListen ID of the HCS topic.
+     * @return The topic listener for this message on a mirror node.
+     */
+    protected provideTopicListener(topicIdToListen: TopicId): HcsDidTopicListener;
+    /**
+     * Handles the error.
+     * If external error handler is defined, passes the error there, otherwise raises RuntimeException.
+     *
+     * @param err The error.
+     * @throws RuntimeException Runtime exception with the given error in case external error handler is not defined.
+     */
+    protected handleError(err: Error): void;
+    /**
+     * Handles event from a mirror node when a message was consensus was reached and message received.
+     *
+     * @param receiver The receiver handling incoming message.
+     * @return This transaction instance.
+     */
+    onMessageConfirmed(receiver: (input: MessageEnvelope<HcsDidMessage>) => void): HcsDidTransaction;
+    /**
+     * Defines a handler for errors when they happen during execution.
+     *
+     * @param handler The error handler.
+     * @return This transaction instance.
+     */
+    onError(handler: (input: Error) => void): HcsDidTransaction;
+    /**
+     * Defines a function that signs the message.
+     *
+     * @param signer The signing function to set.
+     * @return This transaction instance.
+     */
+    signMessage(signer: Signer<Uint8Array>): HcsDidTransaction;
+    /**
+     * Sets {@link TopicMessageSubmitTransaction} parameters, builds and signs it without executing it.
+     * Topic ID and transaction message content are already set in the incoming transaction.
+     *
+     * @param builderFunction The transaction builder function.
+     * @return This transaction instance.
+     */
+    buildAndSignTransaction(builderFunction: (input: TopicMessageSubmitTransaction) => Promise<Transaction>): HcsDidTransaction;
+    /**
+     * Builds the message and submits it to appnet's topic.
+     *
+     * @param client The hedera network client.
+     * @return Transaction ID.
+     */
+    execute(client: Client): Promise<TransactionId>;
+    /**
+     * Runs validation logic.
+     *
+     * @param validator The errors validator.
+     */
+    protected validate(validator: Validator): void;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-transaction.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-transaction.js
new file mode 100644
index 0000000..bc98f20
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did-transaction.js
@@ -0,0 +1,176 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDidTransaction = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const moment_1 = __importDefault(require("moment"));
+const arrays_utils_1 = require("../../../utils/arrays-utils");
+const validator_1 = require("../../../utils/validator");
+const did_error_1 = require("../../did-error");
+const message_envelope_1 = require("../message-envelope");
+const hcs_did_topic_listener_1 = require("./hcs-did-topic-listener");
+/**
+ * The DID document creation, update or deletion transaction.
+ * Builds a correct {@link HcsDidMessage} and send it to HCS DID topic.
+ */
+class HcsDidTransaction {
+    /**
+     * Instantiates a new transaction object from a message that was already prepared.
+     *
+     * @param topicId The HCS DID topic ID where message will be submitted.
+     * @param message The message envelope.
+     */
+    constructor(message, topicId) {
+        if (message instanceof message_envelope_1.MessageEnvelope && topicId instanceof sdk_1.TopicId) {
+            this.topicId = topicId;
+            this.message = message;
+            this.executed = false;
+        }
+        else {
+            throw new did_error_1.DidError("Invalid arguments");
+        }
+    }
+    /**
+     * Provides a {@link MessageListener} instance specific to the submitted message type.
+     *
+     * @param topicIdToListen ID of the HCS topic.
+     * @return The topic listener for this message on a mirror node.
+     */
+    provideTopicListener(topicIdToListen) {
+        return new hcs_did_topic_listener_1.HcsDidTopicListener(topicIdToListen);
+    }
+    /**
+     * Handles the error.
+     * If external error handler is defined, passes the error there, otherwise raises RuntimeException.
+     *
+     * @param err The error.
+     * @throws RuntimeException Runtime exception with the given error in case external error handler is not defined.
+     */
+    handleError(err) {
+        if (this.errorHandler) {
+            this.errorHandler(err);
+        }
+        else {
+            throw new did_error_1.DidError(err.message);
+        }
+    }
+    /**
+     * Handles event from a mirror node when a message was consensus was reached and message received.
+     *
+     * @param receiver The receiver handling incoming message.
+     * @return This transaction instance.
+     */
+    onMessageConfirmed(receiver) {
+        this.receiver = receiver;
+        return this;
+    }
+    /**
+     * Defines a handler for errors when they happen during execution.
+     *
+     * @param handler The error handler.
+     * @return This transaction instance.
+     */
+    onError(handler) {
+        this.errorHandler = handler;
+        return this;
+    }
+    /**
+     * Defines a function that signs the message.
+     *
+     * @param signer The signing function to set.
+     * @return This transaction instance.
+     */
+    signMessage(signer) {
+        this.signer = signer;
+        return this;
+    }
+    /**
+     * Sets {@link TopicMessageSubmitTransaction} parameters, builds and signs it without executing it.
+     * Topic ID and transaction message content are already set in the incoming transaction.
+     *
+     * @param builderFunction The transaction builder function.
+     * @return This transaction instance.
+     */
+    buildAndSignTransaction(builderFunction) {
+        this.buildTransactionFunction = builderFunction;
+        return this;
+    }
+    /**
+     * Builds the message and submits it to appnet's topic.
+     *
+     * @param client The hedera network client.
+     * @return Transaction ID.
+     */
+    execute(client) {
+        return __awaiter(this, void 0, void 0, function* () {
+            new validator_1.Validator().checkValidationErrors("MessageTransaction execution failed: ", (v) => {
+                return this.validate(v);
+            });
+            const envelope = this.message;
+            const messageContent = !envelope.getSignature()
+                ? envelope.sign(this.signer)
+                : arrays_utils_1.ArraysUtils.fromString(envelope.toJSON());
+            if (this.receiver) {
+                this.listener = this.provideTopicListener(this.topicId);
+                this.listener
+                    .setStartTime(sdk_1.Timestamp.fromDate((0, moment_1.default)().subtract(HcsDidTransaction.SUBTRACT_TIME, "seconds").toDate()))
+                    .setIgnoreErrors(false)
+                    .addFilter((response) => {
+                    return arrays_utils_1.ArraysUtils.equals(messageContent, response.contents);
+                })
+                    .onError((err) => {
+                    return this.handleError(err);
+                })
+                    .onInvalidMessageReceived((response, reason) => {
+                    if (!arrays_utils_1.ArraysUtils.equals(messageContent, response.contents)) {
+                        return;
+                    }
+                    this.handleError(new did_error_1.DidError(reason + ": " + arrays_utils_1.ArraysUtils.toString(response.contents)));
+                    this.listener.unsubscribe();
+                })
+                    .subscribe(client, (msg) => {
+                    this.listener.unsubscribe();
+                    this.receiver(msg);
+                });
+            }
+            const tx = new sdk_1.TopicMessageSubmitTransaction().setTopicId(this.topicId).setMessage(messageContent);
+            let transactionId;
+            try {
+                const response = yield (yield this.buildTransactionFunction(tx)).execute(client);
+                yield response.getReceipt(client);
+                transactionId = response.transactionId;
+                this.executed = true;
+            }
+            catch (e) {
+                this.handleError(e);
+                if (this.listener) {
+                    this.listener.unsubscribe();
+                }
+            }
+            return transactionId;
+        });
+    }
+    /**
+     * Runs validation logic.
+     *
+     * @param validator The errors validator.
+     */
+    validate(validator) {
+        validator.require(!this.executed, "This transaction has already been executed.");
+        validator.require(!!this.signer || (!!this.message && !!this.message.getSignature()), "Signing function is missing.");
+        validator.require(!!this.buildTransactionFunction, "Transaction builder is missing.");
+    }
+}
+exports.HcsDidTransaction = HcsDidTransaction;
+HcsDidTransaction.SUBTRACT_TIME = 1; // seconds
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did.d.ts
new file mode 100644
index 0000000..163becc
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did.d.ts
@@ -0,0 +1,162 @@
+import { Client, Hbar, PrivateKey, PublicKey, Timestamp, TopicId } from "@hashgraph/sdk";
+import { DidDocument } from "../../did-document";
+import { DidSyntax } from "../../did-syntax";
+import { MessageEnvelope } from "../message-envelope";
+import { ServiceTypes } from "./event/service/types";
+import { VerificationMethodSupportedKeyType } from "./event/verification-method/types";
+import { VerificationRelationshipSupportedKeyType, VerificationRelationshipType } from "./event/verification-relationship/types";
+import { HcsDidMessage } from "./hcs-did-message";
+export declare class HcsDid {
+    static DID_METHOD: DidSyntax.Method;
+    static TRANSACTION_FEE: Hbar;
+    static READ_TOPIC_MESSAGES_TIMEOUT: number;
+    protected client: Client;
+    protected privateKey: PrivateKey;
+    protected identifier: string;
+    protected network: string;
+    protected topicId: TopicId;
+    protected messages: HcsDidMessage[];
+    protected resolvedAt: Timestamp;
+    protected document: DidDocument;
+    protected onMessageConfirmed: (message: MessageEnvelope<HcsDidMessage>) => void;
+    constructor(args: {
+        identifier?: string;
+        privateKey?: PrivateKey;
+        client?: Client;
+        onMessageConfirmed?: (message: MessageEnvelope<HcsDidMessage>) => void;
+    });
+    /**
+     * Public API
+     */
+    register(): Promise<this>;
+    changeOwner(args: {
+        controller: string;
+        newPrivateKey: PrivateKey;
+    }): Promise<this>;
+    delete(): Promise<this>;
+    resolve(): Promise<DidDocument>;
+    /**
+     *  Meta-information about DID
+     */
+    /**
+     * Add a Service meta-information to DID
+     * @param args
+     * @returns this
+     */
+    addService(args: {
+        id: string;
+        type: ServiceTypes;
+        serviceEndpoint: string;
+    }): Promise<this>;
+    /**
+     * Update a Service meta-information to DID
+     * @param args
+     * @returns this
+     */
+    updateService(args: {
+        id: string;
+        type: ServiceTypes;
+        serviceEndpoint: string;
+    }): Promise<this>;
+    /**
+     * Revoke a Service meta-information to DID
+     * @param args
+     * @returns this
+     */
+    revokeService(args: {
+        id: string;
+    }): Promise<this>;
+    /**
+     * Add a Verification Method meta-information to DID
+     * @param args
+     * @returns this
+     */
+    addVerificationMethod(args: {
+        id: string;
+        type: VerificationMethodSupportedKeyType;
+        controller: string;
+        publicKey: PublicKey;
+    }): Promise<this>;
+    /**
+     * Update a Verification Method meta-information to DID
+     * @param args
+     * @returns this
+     */
+    updateVerificationMethod(args: {
+        id: string;
+        type: VerificationMethodSupportedKeyType;
+        controller: string;
+        publicKey: PublicKey;
+    }): Promise<this>;
+    /**
+     * Revoke a Verification Method meta-information to DID
+     * @param args
+     * @returns this
+     */
+    revokeVerificationMethod(args: {
+        id: string;
+    }): Promise<this>;
+    /**
+     * Add a Verification Relationship to DID
+     * @param args
+     * @returns this
+     */
+    addVerificationRelationship(args: {
+        id: string;
+        relationshipType: VerificationRelationshipType;
+        type: VerificationRelationshipSupportedKeyType;
+        controller: string;
+        publicKey: PublicKey;
+    }): Promise<this>;
+    /**
+     * Update a Verification Relationship to DID
+     * @param args
+     * @returns this
+     */
+    updateVerificationRelationship(args: {
+        id: string;
+        relationshipType: VerificationRelationshipType;
+        type: VerificationRelationshipSupportedKeyType;
+        controller: string;
+        publicKey: PublicKey;
+    }): Promise<this>;
+    /**
+     * Revoke a Verification Relationship to DID
+     * @param args
+     * @returns this
+     */
+    revokeVerificationRelationship(args: {
+        id: string;
+        relationshipType: VerificationRelationshipType;
+    }): Promise<this>;
+    /**
+     * Attribute getters
+     */
+    getIdentifier(): string;
+    getClient(): Client;
+    getPrivateKey(): PrivateKey;
+    getTopicId(): TopicId;
+    getNetwork(): string;
+    getMethod(): DidSyntax.Method;
+    getMessages(): HcsDidMessage[];
+    /**
+     * Static methods
+     */
+    static publicKeyToIdString(publicKey: PublicKey): string;
+    static stringToPublicKey(idString: string): PublicKey;
+    static parsePublicKeyFromIdentifier(identifier: string): PublicKey;
+    /**
+     * Private
+     */
+    private buildIdentifier;
+    static parseIdentifier(identifier: string): [string, TopicId, string];
+    private validateClientConfig;
+    /**
+     * Submit Message Transaction to Hashgraph
+     * @param didMethodOperation
+     * @param event
+     * @param privateKey
+     * @returns this
+     */
+    private submitTransaction;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did.js
new file mode 100644
index 0000000..5d11000
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/did/hcs-did.js
@@ -0,0 +1,416 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.HcsDid = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const hashing_1 = require("../../../utils/hashing");
+const did_document_1 = require("../../did-document");
+const did_error_1 = require("../../did-error");
+const did_method_operation_1 = require("../../did-method-operation");
+const did_syntax_1 = require("../../did-syntax");
+const message_envelope_1 = require("../message-envelope");
+const hcs_did_delete_event_1 = require("./event/document/hcs-did-delete-event");
+const hcs_did_create_did_owner_event_1 = require("./event/owner/hcs-did-create-did-owner-event");
+const hcs_did_update_did_owner_event_1 = require("./event/owner/hcs-did-update-did-owner-event");
+const hcs_did_create_service_event_1 = require("./event/service/hcs-did-create-service-event");
+const hcs_did_revoke_service_event_1 = require("./event/service/hcs-did-revoke-service-event");
+const hcs_did_update_service_event_1 = require("./event/service/hcs-did-update-service-event");
+const hcs_did_create_verification_method_event_1 = require("./event/verification-method/hcs-did-create-verification-method-event");
+const hcs_did_revoke_verification_method_event_1 = require("./event/verification-method/hcs-did-revoke-verification-method-event");
+const hcs_did_update_verification_method_event_1 = require("./event/verification-method/hcs-did-update-verification-method-event");
+const hcs_did_create_verification_relationship_event_1 = require("./event/verification-relationship/hcs-did-create-verification-relationship-event");
+const hcs_did_revoke_verification_relationship_event_1 = require("./event/verification-relationship/hcs-did-revoke-verification-relationship-event");
+const hcs_did_update_verification_relationship_event_1 = require("./event/verification-relationship/hcs-did-update-verification-relationship-event");
+const hcs_did_event_message_resolver_1 = require("./hcs-did-event-message-resolver");
+const hcs_did_message_1 = require("./hcs-did-message");
+const hcs_did_transaction_1 = require("./hcs-did-transaction");
+class HcsDid {
+    constructor(args) {
+        this.identifier = args.identifier;
+        this.privateKey = args.privateKey;
+        this.client = args.client;
+        this.onMessageConfirmed = args.onMessageConfirmed;
+        if (!this.identifier && !this.privateKey) {
+            throw new did_error_1.DidError("identifier and privateKey cannot both be empty");
+        }
+        if (this.identifier) {
+            const [networkName, topicId] = HcsDid.parseIdentifier(this.identifier);
+            this.network = networkName;
+            this.topicId = topicId;
+        }
+    }
+    /**
+     * Public API
+     */
+    register() {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            if (this.identifier) {
+                yield this.resolve();
+                if (this.document.hasOwner()) {
+                    throw new did_error_1.DidError("DID is already registered");
+                }
+            }
+            else {
+                /**
+                 * Create topic
+                 */
+                const topicCreateTransaction = new sdk_1.TopicCreateTransaction()
+                    .setMaxTransactionFee(HcsDid.TRANSACTION_FEE)
+                    .setAdminKey(this.privateKey.publicKey)
+                    .setSubmitKey(this.privateKey.publicKey)
+                    .freezeWith(this.client);
+                const sigTx = yield topicCreateTransaction.sign(this.privateKey);
+                const txId = yield sigTx.execute(this.client);
+                const topicId = (yield txId.getReceipt(this.client)).topicId;
+                this.topicId = topicId;
+                this.network = this.client.ledgerId.toString();
+                this.identifier = this.buildIdentifier(this.privateKey.publicKey);
+            }
+            /**
+             * Set ownership
+             */
+            const event = new hcs_did_create_did_owner_event_1.HcsDidCreateDidOwnerEvent(this.identifier + "#did-root-key", this.identifier, this.privateKey.publicKey);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.CREATE, event, this.privateKey);
+            return this;
+        });
+    }
+    changeOwner(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.identifier) {
+                throw new did_error_1.DidError("DID is not registered");
+            }
+            this.validateClientConfig();
+            if (!args.newPrivateKey) {
+                throw new did_error_1.DidError("newPrivateKey is missing");
+            }
+            yield this.resolve();
+            if (!this.document.hasOwner()) {
+                throw new did_error_1.DidError("DID is not registered or was recently deleted. DID has to be registered first.");
+            }
+            /**
+             * Change owner of the topic
+             */
+            const transaction = yield new sdk_1.TopicUpdateTransaction()
+                .setTopicId(this.topicId)
+                .setAdminKey(args.newPrivateKey.publicKey)
+                .setSubmitKey(args.newPrivateKey.publicKey)
+                .freezeWith(this.client);
+            const signTx = yield (yield transaction.sign(this.privateKey)).sign(args.newPrivateKey);
+            const txResponse = yield signTx.execute(this.client);
+            yield txResponse.getReceipt(this.client);
+            this.privateKey = args.newPrivateKey;
+            /**
+             * Send ownership change message to the topic
+             */
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.UPDATE, new hcs_did_update_did_owner_event_1.HcsDidUpdateDidOwnerEvent(this.getIdentifier() + "#did-root-key", args.controller, args.newPrivateKey.publicKey), this.privateKey);
+            return this;
+        });
+    }
+    delete() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.identifier) {
+                throw new did_error_1.DidError("DID is not registered");
+            }
+            this.validateClientConfig();
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.DELETE, new hcs_did_delete_event_1.HcsDidDeleteEvent(), this.privateKey);
+            return this;
+        });
+    }
+    resolve() {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.identifier) {
+                throw new did_error_1.DidError("DID is not registered");
+            }
+            if (!this.client) {
+                throw new did_error_1.DidError("Client configuration is missing");
+            }
+            return new Promise((resolve, reject) => {
+                new hcs_did_event_message_resolver_1.HcsDidEventMessageResolver(this.topicId)
+                    .setTimeout(HcsDid.READ_TOPIC_MESSAGES_TIMEOUT)
+                    .whenFinished((messages) => __awaiter(this, void 0, void 0, function* () {
+                    this.messages = messages.map((msg) => msg.open());
+                    this.document = new did_document_1.DidDocument(this.identifier);
+                    try {
+                        yield this.document.processMessages(this.messages);
+                        resolve(this.document);
+                    }
+                    catch (err) {
+                        reject(err);
+                    }
+                }))
+                    .onError((err) => {
+                    // console.error(err);
+                    reject(err);
+                })
+                    .execute(this.client);
+            });
+        });
+    }
+    /**
+     *  Meta-information about DID
+     */
+    /**
+     * Add a Service meta-information to DID
+     * @param args
+     * @returns this
+     */
+    addService(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_create_service_event_1.HcsDidCreateServiceEvent(args.id, args.type, args.serviceEndpoint);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.CREATE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Update a Service meta-information to DID
+     * @param args
+     * @returns this
+     */
+    updateService(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_update_service_event_1.HcsDidUpdateServiceEvent(args.id, args.type, args.serviceEndpoint);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.UPDATE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Revoke a Service meta-information to DID
+     * @param args
+     * @returns this
+     */
+    revokeService(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_revoke_service_event_1.HcsDidRevokeServiceEvent(args.id);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.REVOKE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Add a Verification Method meta-information to DID
+     * @param args
+     * @returns this
+     */
+    addVerificationMethod(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_create_verification_method_event_1.HcsDidCreateVerificationMethodEvent(args.id, args.type, args.controller, args.publicKey);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.CREATE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Update a Verification Method meta-information to DID
+     * @param args
+     * @returns this
+     */
+    updateVerificationMethod(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_update_verification_method_event_1.HcsDidUpdateVerificationMethodEvent(args.id, args.type, args.controller, args.publicKey);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.UPDATE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Revoke a Verification Method meta-information to DID
+     * @param args
+     * @returns this
+     */
+    revokeVerificationMethod(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_revoke_verification_method_event_1.HcsDidRevokeVerificationMethodEvent(args.id);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.REVOKE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Add a Verification Relationship to DID
+     * @param args
+     * @returns this
+     */
+    addVerificationRelationship(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_create_verification_relationship_event_1.HcsDidCreateVerificationRelationshipEvent(args.id, args.relationshipType, args.type, args.controller, args.publicKey);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.CREATE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Update a Verification Relationship to DID
+     * @param args
+     * @returns this
+     */
+    updateVerificationRelationship(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_update_verification_relationship_event_1.HcsDidUpdateVerificationRelationshipEvent(args.id, args.relationshipType, args.type, args.controller, args.publicKey);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.UPDATE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Revoke a Verification Relationship to DID
+     * @param args
+     * @returns this
+     */
+    revokeVerificationRelationship(args) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.validateClientConfig();
+            const event = new hcs_did_revoke_verification_relationship_event_1.HcsDidRevokeVerificationRelationshipEvent(args.id, args.relationshipType);
+            yield this.submitTransaction(did_method_operation_1.DidMethodOperation.REVOKE, event, this.privateKey);
+            return this;
+        });
+    }
+    /**
+     * Attribute getters
+     */
+    getIdentifier() {
+        return this.identifier;
+    }
+    getClient() {
+        return this.client;
+    }
+    getPrivateKey() {
+        return this.privateKey;
+    }
+    getTopicId() {
+        return this.topicId;
+    }
+    getNetwork() {
+        return this.network;
+    }
+    getMethod() {
+        return HcsDid.DID_METHOD;
+    }
+    getMessages() {
+        return this.messages;
+    }
+    /**
+     * Static methods
+     */
+    static publicKeyToIdString(publicKey) {
+        return hashing_1.Hashing.multibase.encode(publicKey.toBytes());
+    }
+    static stringToPublicKey(idString) {
+        return sdk_1.PublicKey.fromBytes(hashing_1.Hashing.multibase.decode(idString));
+    }
+    static parsePublicKeyFromIdentifier(identifier) {
+        const [_networkName, _topicId, didIdString] = HcsDid.parseIdentifier(identifier);
+        return HcsDid.stringToPublicKey(didIdString);
+    }
+    /**
+     * Private
+     */
+    buildIdentifier(publicKey) {
+        const methodNetwork = [this.getMethod().toString(), this.network].join(did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR);
+        let ret;
+        ret =
+            did_syntax_1.DidSyntax.DID_PREFIX +
+                did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR +
+                methodNetwork +
+                did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR +
+                HcsDid.publicKeyToIdString(publicKey) +
+                did_syntax_1.DidSyntax.DID_TOPIC_SEPARATOR +
+                this.topicId.toString();
+        return ret;
+    }
+    static parseIdentifier(identifier) {
+        const [didPart, topicIdPart] = identifier.split(did_syntax_1.DidSyntax.DID_TOPIC_SEPARATOR);
+        if (!topicIdPart) {
+            throw new did_error_1.DidError("DID string is invalid: topic ID is missing", did_error_1.DidErrorCode.INVALID_DID_STRING);
+        }
+        const topicId = sdk_1.TopicId.fromString(topicIdPart);
+        const didParts = didPart.split(did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR);
+        if (didParts.shift() !== did_syntax_1.DidSyntax.DID_PREFIX) {
+            throw new did_error_1.DidError("DID string is invalid: invalid prefix.", did_error_1.DidErrorCode.INVALID_DID_STRING);
+        }
+        const methodName = didParts.shift();
+        if (did_syntax_1.DidSyntax.Method.HEDERA_HCS !== methodName) {
+            throw new did_error_1.DidError("DID string is invalid: invalid method name: " + methodName, did_error_1.DidErrorCode.INVALID_DID_STRING);
+        }
+        try {
+            const networkName = didParts.shift();
+            if (networkName != did_syntax_1.DidSyntax.HEDERA_NETWORK_MAINNET &&
+                networkName != did_syntax_1.DidSyntax.HEDERA_NETWORK_TESTNET &&
+                networkName != did_syntax_1.DidSyntax.HEDERA_NETWORK_PREVIEWNET) {
+                throw new did_error_1.DidError("DID string is invalid. Invalid Hedera network.", did_error_1.DidErrorCode.INVALID_NETWORK);
+            }
+            const didIdString = didParts.shift();
+            if (didIdString.length < 44 || didParts.shift()) {
+                throw new did_error_1.DidError("DID string is invalid. ID holds incorrect format.", did_error_1.DidErrorCode.INVALID_DID_STRING);
+            }
+            return [networkName, topicId, didIdString];
+        }
+        catch (e) {
+            if (e instanceof did_error_1.DidError) {
+                throw e;
+            }
+            throw new did_error_1.DidError("DID string is invalid. " + e.message, did_error_1.DidErrorCode.INVALID_DID_STRING);
+        }
+    }
+    validateClientConfig() {
+        if (!this.privateKey) {
+            throw new did_error_1.DidError("privateKey is missing");
+        }
+        if (!this.client) {
+            throw new did_error_1.DidError("Client configuration is missing");
+        }
+    }
+    /**
+     * Submit Message Transaction to Hashgraph
+     * @param didMethodOperation
+     * @param event
+     * @param privateKey
+     * @returns this
+     */
+    submitTransaction(didMethodOperation, event, privateKey) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const message = new hcs_did_message_1.HcsDidMessage(didMethodOperation, this.getIdentifier(), event);
+            const envelope = new message_envelope_1.MessageEnvelope(message);
+            const transaction = new hcs_did_transaction_1.HcsDidTransaction(envelope, this.getTopicId());
+            return new Promise((resolve, reject) => {
+                transaction
+                    .signMessage((msg) => {
+                    return privateKey.sign(msg);
+                })
+                    .buildAndSignTransaction((tx) => {
+                    return tx
+                        .setMaxTransactionFee(HcsDid.TRANSACTION_FEE)
+                        .freezeWith(this.client)
+                        .sign(this.privateKey);
+                })
+                    .onError((err) => {
+                    // console.error(err);
+                    reject(err);
+                })
+                    .onMessageConfirmed((msg) => {
+                    if (this.onMessageConfirmed) {
+                        this.onMessageConfirmed(msg);
+                    }
+                    console.log("Message Published");
+                    console.log(`Explore on DragonGlass: https://testnet.dragonglass.me/hedera/topics/${this.getTopicId()}`);
+                    resolve(msg);
+                })
+                    .execute(this.client);
+            });
+        });
+    }
+}
+exports.HcsDid = HcsDid;
+HcsDid.DID_METHOD = did_syntax_1.DidSyntax.Method.HEDERA_HCS;
+HcsDid.TRANSACTION_FEE = new sdk_1.Hbar(2);
+HcsDid.READ_TOPIC_MESSAGES_TIMEOUT = 5000;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/json-class.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/json-class.d.ts
new file mode 100644
index 0000000..3c0449b
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/json-class.d.ts
@@ -0,0 +1,3 @@
+export declare type JsonClass<U> = {
+    fromJsonTree(json: any, result?: U): U;
+};
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/json-class.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/json-class.js
new file mode 100644
index 0000000..c8ad2e5
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/json-class.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/message-envelope.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/message-envelope.d.ts
new file mode 100644
index 0000000..e38de30
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/message-envelope.d.ts
@@ -0,0 +1,77 @@
+import { PublicKey, Timestamp, TopicMessage } from "@hashgraph/sdk";
+import { HcsDidMessage } from "../..";
+import { JsonClass } from "./json-class";
+import { SerializableMirrorConsensusResponse } from "./serializable-mirror-consensus-response";
+export declare type PublicKeyProvider<T extends HcsDidMessage> = (evn: MessageEnvelope<T>) => PublicKey;
+export declare type SignFunction = (message: Uint8Array) => Uint8Array;
+/**
+ * The envelope for Hedera identity messages sent to HCS DID or VC topics.
+ */
+export declare class MessageEnvelope<T extends HcsDidMessage> {
+    private static MESSAGE_KEY;
+    private static SIGNATURE_KEY;
+    private static serialVersionUID;
+    protected message: T;
+    protected signature: string;
+    protected get messageJson(): string;
+    protected mirrorResponse: SerializableMirrorConsensusResponse;
+    /**
+     * Creates a new message envelope for the given message.
+     *
+     * @param message The message.
+     */
+    constructor(message: T);
+    constructor();
+    /**
+     * Signs this message envelope with the given signing function.
+     *
+     * @param signer The signing function.
+     * @return This envelope signed and serialized to JSON, ready for submission to HCS topic.
+     */
+    sign(signer: SignFunction): Uint8Array;
+    toJsonTree(): any;
+    /**
+     * Converts this message envelope into a JSON string.
+     *
+     * @return The JSON string representing this message envelope.
+     */
+    toJSON(): string;
+    /**
+     * Converts a message from a DID or VC topic response into object instance.
+     *
+     * @param <U>          Type of the message inside envelope.
+     * @param response     Topic message as a response from mirror node.
+     * @param messageClass Class type of the message inside envelope.
+     * @return The {@link MessageEnvelope}.
+     */
+    static fromMirrorResponse<U extends HcsDidMessage>(response: TopicMessage, messageClass: JsonClass<U>): MessageEnvelope<U>;
+    /**
+     * Converts a VC topic message from a JSON string into object instance.
+     *
+     * @param <U>          Type of the message inside envelope.
+     * @param json         VC topic message as JSON string.
+     * @param messageClass Class of the message inside envelope.
+     * @return The {@link MessageEnvelope}.
+     */
+    static fromJson<U extends HcsDidMessage>(json: string, messageClass: JsonClass<U>): MessageEnvelope<U>;
+    /**
+     * Verifies the signature of the envelope against the public key of it's signer.
+     *
+     * @param publicKeyProvider Provider of a public key of this envelope signer.
+     * @return True if the message is valid, false otherwise.
+     */
+    isSignatureValid(publicKeyProvider: PublicKeyProvider<T>): boolean;
+    isSignatureValid(publicKey: PublicKey): boolean;
+    /**
+     * Opens a message in this envelope.
+     * If the message is encrypted, the given decrypter will be used first to decrypt it.
+     * If the message is not encrypted, it will be immediately returned.
+     *
+     * @param decrypter The function used to decrypt the message.
+     * @return The message object in a plain mode.
+     */
+    open(): T;
+    getSignature(): string;
+    getConsensusTimestamp(): Timestamp;
+    getMirrorResponse(): SerializableMirrorConsensusResponse;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/message-envelope.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/message-envelope.js
new file mode 100644
index 0000000..e171457
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/message-envelope.js
@@ -0,0 +1,156 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MessageEnvelope = void 0;
+const js_base64_1 = require("js-base64");
+const long_1 = __importDefault(require("long"));
+const arrays_utils_1 = require("../../utils/arrays-utils");
+const did_error_1 = require("../did-error");
+const serializable_mirror_consensus_response_1 = require("./serializable-mirror-consensus-response");
+/**
+ * The envelope for Hedera identity messages sent to HCS DID or VC topics.
+ */
+class MessageEnvelope {
+    constructor(...args) {
+        if (args.length === 0) {
+            // do nothing
+        }
+        else if (args.length === 1) {
+            const [message] = args;
+            this.message = message;
+        }
+        else {
+            throw new did_error_1.DidError("Wrong arguments passed to constructor");
+        }
+    }
+    get messageJson() {
+        if (!this.message) {
+            return null;
+        }
+        return this.message.toJSON();
+    }
+    /**
+     * Signs this message envelope with the given signing function.
+     *
+     * @param signer The signing function.
+     * @return This envelope signed and serialized to JSON, ready for submission to HCS topic.
+     */
+    sign(signer) {
+        if (!signer) {
+            throw new did_error_1.DidError("Signing function is not provided.");
+        }
+        if (this.signature) {
+            throw new did_error_1.DidError("Message is already signed.");
+        }
+        const msgBytes = arrays_utils_1.ArraysUtils.fromString(this.message.toJSON());
+        const signatureBytes = signer(msgBytes);
+        this.signature = js_base64_1.Base64.fromUint8Array(signatureBytes);
+        return arrays_utils_1.ArraysUtils.fromString(this.toJSON());
+    }
+    toJsonTree() {
+        const result = {};
+        if (this.message) {
+            result[MessageEnvelope.MESSAGE_KEY] = this.message.toJsonTree();
+        }
+        if (this.signature) {
+            result[MessageEnvelope.SIGNATURE_KEY] = this.signature;
+        }
+        return result;
+    }
+    /**
+     * Converts this message envelope into a JSON string.
+     *
+     * @return The JSON string representing this message envelope.
+     */
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+    /**
+     * Converts a message from a DID or VC topic response into object instance.
+     *
+     * @param <U>          Type of the message inside envelope.
+     * @param response     Topic message as a response from mirror node.
+     * @param messageClass Class type of the message inside envelope.
+     * @return The {@link MessageEnvelope}.
+     */
+    static fromMirrorResponse(response, messageClass) {
+        const msgJson = arrays_utils_1.ArraysUtils.toString(response.contents);
+        const result = MessageEnvelope.fromJson(msgJson, messageClass);
+        // console.log(result);
+        result.mirrorResponse = new serializable_mirror_consensus_response_1.SerializableMirrorConsensusResponse(response);
+        return result;
+    }
+    /**
+     * Converts a VC topic message from a JSON string into object instance.
+     *
+     * @param <U>          Type of the message inside envelope.
+     * @param json         VC topic message as JSON string.
+     * @param messageClass Class of the message inside envelope.
+     * @return The {@link MessageEnvelope}.
+     */
+    static fromJson(json, messageClass) {
+        const result = new MessageEnvelope();
+        let root;
+        try {
+            root = JSON.parse(json);
+            result.signature = root[MessageEnvelope.SIGNATURE_KEY];
+            if (root.hasOwnProperty(MessageEnvelope.MESSAGE_KEY)) {
+                result.message = messageClass.fromJsonTree(root[MessageEnvelope.MESSAGE_KEY]);
+            }
+            else {
+                result.message = null;
+            }
+        }
+        catch (err) {
+            console.warn(`Invalid message JSON message - it will be ignored`);
+            // Invalid json - ignore the message
+            result.message = null;
+        }
+        return result;
+    }
+    isSignatureValid(...args) {
+        if (!this.signature || !this.message) {
+            return false;
+        }
+        let publicKey;
+        if (typeof args[0] == "function") {
+            const publicKeyProvider = args[0];
+            publicKey = publicKeyProvider(this);
+        }
+        else {
+            publicKey = args[0];
+        }
+        if (!publicKey) {
+            return false;
+        }
+        const signatureToVerify = js_base64_1.Base64.toUint8Array(this.signature);
+        const messageBytes = arrays_utils_1.ArraysUtils.fromString(this.message.toJSON());
+        return publicKey.verify(messageBytes, signatureToVerify);
+    }
+    /**
+     * Opens a message in this envelope.
+     * If the message is encrypted, the given decrypter will be used first to decrypt it.
+     * If the message is not encrypted, it will be immediately returned.
+     *
+     * @param decrypter The function used to decrypt the message.
+     * @return The message object in a plain mode.
+     */
+    open() {
+        return this.message;
+    }
+    getSignature() {
+        return this.signature;
+    }
+    getConsensusTimestamp() {
+        return !this.mirrorResponse ? null : this.mirrorResponse.consensusTimestamp;
+    }
+    getMirrorResponse() {
+        return this.mirrorResponse;
+    }
+}
+exports.MessageEnvelope = MessageEnvelope;
+MessageEnvelope.MESSAGE_KEY = "message";
+MessageEnvelope.SIGNATURE_KEY = "signature";
+MessageEnvelope.serialVersionUID = long_1.default.fromInt(1);
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/serializable-mirror-consensus-response.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/serializable-mirror-consensus-response.d.ts
new file mode 100644
index 0000000..a548707
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/serializable-mirror-consensus-response.d.ts
@@ -0,0 +1,13 @@
+import Long from "long";
+import { Timestamp, TopicMessage } from "@hashgraph/sdk";
+export declare class SerializableMirrorConsensusResponse {
+    private static serialVersionUID;
+    consensusTimestamp: Timestamp;
+    message: Uint8Array;
+    runningHash: Uint8Array;
+    sequenceNumber: Long;
+    constructor(response: TopicMessage);
+    toString(): string;
+    toJsonTree(): any;
+    toJSON(): string;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/serializable-mirror-consensus-response.js b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/serializable-mirror-consensus-response.js
new file mode 100644
index 0000000..8767e4c
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/identity/hcs/serializable-mirror-consensus-response.js
@@ -0,0 +1,45 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.SerializableMirrorConsensusResponse = void 0;
+const long_1 = __importDefault(require("long"));
+const arrays_utils_1 = require("../../utils/arrays-utils");
+const timestamp_utils_1 = require("../../utils/timestamp-utils");
+class SerializableMirrorConsensusResponse {
+    constructor(response) {
+        this.consensusTimestamp = response.consensusTimestamp;
+        this.message = response.contents;
+        this.runningHash = response.runningHash;
+        this.sequenceNumber = response.sequenceNumber;
+    }
+    toString() {
+        return ("ConsensusMessage{" +
+            "consensusTimestamp=" +
+            timestamp_utils_1.TimestampUtils.toJSON(this.consensusTimestamp) +
+            ", message=" +
+            arrays_utils_1.ArraysUtils.toString(this.message) +
+            ", runningHash=" +
+            arrays_utils_1.ArraysUtils.toString(this.runningHash) +
+            ", sequenceNumber=" +
+            this.sequenceNumber.toNumber() +
+            "}");
+    }
+    toJsonTree() {
+        const result = {};
+        result.consensusTimestamp = {
+            seconds: this.consensusTimestamp.seconds,
+            nanos: this.consensusTimestamp.nanos,
+        };
+        result.message = this.message.toString();
+        result.runningHash = this.runningHash.toString();
+        result.sequenceNumber = this.sequenceNumber.toString();
+        return result;
+    }
+    toJSON() {
+        return JSON.stringify(this.toJsonTree());
+    }
+}
+exports.SerializableMirrorConsensusResponse = SerializableMirrorConsensusResponse;
+SerializableMirrorConsensusResponse.serialVersionUID = long_1.default.fromInt(1);
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/index.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/index.d.ts
new file mode 100644
index 0000000..c839852
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/index.d.ts
@@ -0,0 +1,35 @@
+import { DidDocument } from "./identity/did-document";
+import { DidDocumentJsonProperties } from "./identity/did-document-json-properties";
+import { DidError, DidErrorCode } from "./identity/did-error";
+import { DidMethodOperation } from "./identity/did-method-operation";
+import { DidParser } from "./identity/did-parser";
+import { HederaDidResolver } from "./identity/did-resolver";
+import { DidSyntax } from "./identity/did-syntax";
+import { HcsDidCreateDidDocumentEvent } from "./identity/hcs/did/event/document/hcs-did-create-did-document-event";
+import { HcsDidDeleteEvent } from "./identity/hcs/did/event/document/hcs-did-delete-event";
+import { HcsDidEventTargetName } from "./identity/hcs/did/event/hcs-did-event-target-name";
+import { HcsDidCreateDidOwnerEvent } from "./identity/hcs/did/event/owner/hcs-did-create-did-owner-event";
+import { HcsDidUpdateDidOwnerEvent } from "./identity/hcs/did/event/owner/hcs-did-update-did-owner-event";
+import { HcsDidCreateServiceEvent } from "./identity/hcs/did/event/service/hcs-did-create-service-event";
+import { HcsDidRevokeServiceEvent } from "./identity/hcs/did/event/service/hcs-did-revoke-service-event";
+import { HcsDidUpdateServiceEvent } from "./identity/hcs/did/event/service/hcs-did-update-service-event";
+import { HcsDidCreateVerificationMethodEvent } from "./identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event";
+import { HcsDidRevokeVerificationMethodEvent } from "./identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event";
+import { HcsDidUpdateVerificationMethodEvent } from "./identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event";
+import { HcsDidCreateVerificationRelationshipEvent } from "./identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event";
+import { HcsDidRevokeVerificationRelationshipEvent } from "./identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event";
+import { HcsDidUpdateVerificationRelationshipEvent } from "./identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event";
+import { HcsDid } from "./identity/hcs/did/hcs-did";
+import { HcsDidEventMessageResolver } from "./identity/hcs/did/hcs-did-event-message-resolver";
+import { HcsDidMessage } from "./identity/hcs/did/hcs-did-message";
+import { HcsDidTopicListener } from "./identity/hcs/did/hcs-did-topic-listener";
+import { HcsDidTransaction } from "./identity/hcs/did/hcs-did-transaction";
+import { JsonClass } from "./identity/hcs/json-class";
+import { MessageEnvelope } from "./identity/hcs/message-envelope";
+import { SerializableMirrorConsensusResponse } from "./identity/hcs/serializable-mirror-consensus-response";
+import { ArraysUtils } from "./utils/arrays-utils";
+import { Ed25519PubCodec } from "./utils/ed25519PubCodec";
+import { Hashing } from "./utils/hashing";
+import { TimestampUtils } from "./utils/timestamp-utils";
+import { Validator } from "./utils/validator";
+export { ArraysUtils, DidDocument, DidDocumentJsonProperties, DidError, DidErrorCode, DidMethodOperation, DidParser, DidSyntax, Ed25519PubCodec, Hashing, HcsDid, HcsDidCreateDidDocumentEvent, HcsDidCreateDidOwnerEvent, HcsDidCreateServiceEvent, HcsDidCreateVerificationMethodEvent, HcsDidCreateVerificationRelationshipEvent, HcsDidDeleteEvent, HcsDidEventMessageResolver, HcsDidEventTargetName, HcsDidMessage, HcsDidRevokeServiceEvent, HcsDidRevokeVerificationMethodEvent, HcsDidRevokeVerificationRelationshipEvent, HcsDidTopicListener, HcsDidTransaction, HcsDidUpdateDidOwnerEvent, HcsDidUpdateServiceEvent, HcsDidUpdateVerificationMethodEvent, HcsDidUpdateVerificationRelationshipEvent, HederaDidResolver, JsonClass, MessageEnvelope, SerializableMirrorConsensusResponse, TimestampUtils, Validator, };
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/index.js b/node_modules/@hashgraph/did-sdk-js/dist/index.js
new file mode 100644
index 0000000..c067853
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/index.js
@@ -0,0 +1,70 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.Validator = exports.TimestampUtils = exports.SerializableMirrorConsensusResponse = exports.MessageEnvelope = exports.HederaDidResolver = exports.HcsDidUpdateVerificationRelationshipEvent = exports.HcsDidUpdateVerificationMethodEvent = exports.HcsDidUpdateServiceEvent = exports.HcsDidUpdateDidOwnerEvent = exports.HcsDidTransaction = exports.HcsDidTopicListener = exports.HcsDidRevokeVerificationRelationshipEvent = exports.HcsDidRevokeVerificationMethodEvent = exports.HcsDidRevokeServiceEvent = exports.HcsDidMessage = exports.HcsDidEventTargetName = exports.HcsDidEventMessageResolver = exports.HcsDidDeleteEvent = exports.HcsDidCreateVerificationRelationshipEvent = exports.HcsDidCreateVerificationMethodEvent = exports.HcsDidCreateServiceEvent = exports.HcsDidCreateDidOwnerEvent = exports.HcsDidCreateDidDocumentEvent = exports.HcsDid = exports.Hashing = exports.Ed25519PubCodec = exports.DidSyntax = exports.DidParser = exports.DidMethodOperation = exports.DidErrorCode = exports.DidError = exports.DidDocumentJsonProperties = exports.DidDocument = exports.ArraysUtils = void 0;
+const did_document_1 = require("./identity/did-document");
+Object.defineProperty(exports, "DidDocument", { enumerable: true, get: function () { return did_document_1.DidDocument; } });
+const did_document_json_properties_1 = require("./identity/did-document-json-properties");
+Object.defineProperty(exports, "DidDocumentJsonProperties", { enumerable: true, get: function () { return did_document_json_properties_1.DidDocumentJsonProperties; } });
+const did_error_1 = require("./identity/did-error");
+Object.defineProperty(exports, "DidError", { enumerable: true, get: function () { return did_error_1.DidError; } });
+Object.defineProperty(exports, "DidErrorCode", { enumerable: true, get: function () { return did_error_1.DidErrorCode; } });
+const did_method_operation_1 = require("./identity/did-method-operation");
+Object.defineProperty(exports, "DidMethodOperation", { enumerable: true, get: function () { return did_method_operation_1.DidMethodOperation; } });
+const did_parser_1 = require("./identity/did-parser");
+Object.defineProperty(exports, "DidParser", { enumerable: true, get: function () { return did_parser_1.DidParser; } });
+const did_resolver_1 = require("./identity/did-resolver");
+Object.defineProperty(exports, "HederaDidResolver", { enumerable: true, get: function () { return did_resolver_1.HederaDidResolver; } });
+const did_syntax_1 = require("./identity/did-syntax");
+Object.defineProperty(exports, "DidSyntax", { enumerable: true, get: function () { return did_syntax_1.DidSyntax; } });
+const hcs_did_create_did_document_event_1 = require("./identity/hcs/did/event/document/hcs-did-create-did-document-event");
+Object.defineProperty(exports, "HcsDidCreateDidDocumentEvent", { enumerable: true, get: function () { return hcs_did_create_did_document_event_1.HcsDidCreateDidDocumentEvent; } });
+const hcs_did_delete_event_1 = require("./identity/hcs/did/event/document/hcs-did-delete-event");
+Object.defineProperty(exports, "HcsDidDeleteEvent", { enumerable: true, get: function () { return hcs_did_delete_event_1.HcsDidDeleteEvent; } });
+const hcs_did_event_target_name_1 = require("./identity/hcs/did/event/hcs-did-event-target-name");
+Object.defineProperty(exports, "HcsDidEventTargetName", { enumerable: true, get: function () { return hcs_did_event_target_name_1.HcsDidEventTargetName; } });
+const hcs_did_create_did_owner_event_1 = require("./identity/hcs/did/event/owner/hcs-did-create-did-owner-event");
+Object.defineProperty(exports, "HcsDidCreateDidOwnerEvent", { enumerable: true, get: function () { return hcs_did_create_did_owner_event_1.HcsDidCreateDidOwnerEvent; } });
+const hcs_did_update_did_owner_event_1 = require("./identity/hcs/did/event/owner/hcs-did-update-did-owner-event");
+Object.defineProperty(exports, "HcsDidUpdateDidOwnerEvent", { enumerable: true, get: function () { return hcs_did_update_did_owner_event_1.HcsDidUpdateDidOwnerEvent; } });
+const hcs_did_create_service_event_1 = require("./identity/hcs/did/event/service/hcs-did-create-service-event");
+Object.defineProperty(exports, "HcsDidCreateServiceEvent", { enumerable: true, get: function () { return hcs_did_create_service_event_1.HcsDidCreateServiceEvent; } });
+const hcs_did_revoke_service_event_1 = require("./identity/hcs/did/event/service/hcs-did-revoke-service-event");
+Object.defineProperty(exports, "HcsDidRevokeServiceEvent", { enumerable: true, get: function () { return hcs_did_revoke_service_event_1.HcsDidRevokeServiceEvent; } });
+const hcs_did_update_service_event_1 = require("./identity/hcs/did/event/service/hcs-did-update-service-event");
+Object.defineProperty(exports, "HcsDidUpdateServiceEvent", { enumerable: true, get: function () { return hcs_did_update_service_event_1.HcsDidUpdateServiceEvent; } });
+const hcs_did_create_verification_method_event_1 = require("./identity/hcs/did/event/verification-method/hcs-did-create-verification-method-event");
+Object.defineProperty(exports, "HcsDidCreateVerificationMethodEvent", { enumerable: true, get: function () { return hcs_did_create_verification_method_event_1.HcsDidCreateVerificationMethodEvent; } });
+const hcs_did_revoke_verification_method_event_1 = require("./identity/hcs/did/event/verification-method/hcs-did-revoke-verification-method-event");
+Object.defineProperty(exports, "HcsDidRevokeVerificationMethodEvent", { enumerable: true, get: function () { return hcs_did_revoke_verification_method_event_1.HcsDidRevokeVerificationMethodEvent; } });
+const hcs_did_update_verification_method_event_1 = require("./identity/hcs/did/event/verification-method/hcs-did-update-verification-method-event");
+Object.defineProperty(exports, "HcsDidUpdateVerificationMethodEvent", { enumerable: true, get: function () { return hcs_did_update_verification_method_event_1.HcsDidUpdateVerificationMethodEvent; } });
+const hcs_did_create_verification_relationship_event_1 = require("./identity/hcs/did/event/verification-relationship/hcs-did-create-verification-relationship-event");
+Object.defineProperty(exports, "HcsDidCreateVerificationRelationshipEvent", { enumerable: true, get: function () { return hcs_did_create_verification_relationship_event_1.HcsDidCreateVerificationRelationshipEvent; } });
+const hcs_did_revoke_verification_relationship_event_1 = require("./identity/hcs/did/event/verification-relationship/hcs-did-revoke-verification-relationship-event");
+Object.defineProperty(exports, "HcsDidRevokeVerificationRelationshipEvent", { enumerable: true, get: function () { return hcs_did_revoke_verification_relationship_event_1.HcsDidRevokeVerificationRelationshipEvent; } });
+const hcs_did_update_verification_relationship_event_1 = require("./identity/hcs/did/event/verification-relationship/hcs-did-update-verification-relationship-event");
+Object.defineProperty(exports, "HcsDidUpdateVerificationRelationshipEvent", { enumerable: true, get: function () { return hcs_did_update_verification_relationship_event_1.HcsDidUpdateVerificationRelationshipEvent; } });
+const hcs_did_1 = require("./identity/hcs/did/hcs-did");
+Object.defineProperty(exports, "HcsDid", { enumerable: true, get: function () { return hcs_did_1.HcsDid; } });
+const hcs_did_event_message_resolver_1 = require("./identity/hcs/did/hcs-did-event-message-resolver");
+Object.defineProperty(exports, "HcsDidEventMessageResolver", { enumerable: true, get: function () { return hcs_did_event_message_resolver_1.HcsDidEventMessageResolver; } });
+const hcs_did_message_1 = require("./identity/hcs/did/hcs-did-message");
+Object.defineProperty(exports, "HcsDidMessage", { enumerable: true, get: function () { return hcs_did_message_1.HcsDidMessage; } });
+const hcs_did_topic_listener_1 = require("./identity/hcs/did/hcs-did-topic-listener");
+Object.defineProperty(exports, "HcsDidTopicListener", { enumerable: true, get: function () { return hcs_did_topic_listener_1.HcsDidTopicListener; } });
+const hcs_did_transaction_1 = require("./identity/hcs/did/hcs-did-transaction");
+Object.defineProperty(exports, "HcsDidTransaction", { enumerable: true, get: function () { return hcs_did_transaction_1.HcsDidTransaction; } });
+const message_envelope_1 = require("./identity/hcs/message-envelope");
+Object.defineProperty(exports, "MessageEnvelope", { enumerable: true, get: function () { return message_envelope_1.MessageEnvelope; } });
+const serializable_mirror_consensus_response_1 = require("./identity/hcs/serializable-mirror-consensus-response");
+Object.defineProperty(exports, "SerializableMirrorConsensusResponse", { enumerable: true, get: function () { return serializable_mirror_consensus_response_1.SerializableMirrorConsensusResponse; } });
+const arrays_utils_1 = require("./utils/arrays-utils");
+Object.defineProperty(exports, "ArraysUtils", { enumerable: true, get: function () { return arrays_utils_1.ArraysUtils; } });
+const ed25519PubCodec_1 = require("./utils/ed25519PubCodec");
+Object.defineProperty(exports, "Ed25519PubCodec", { enumerable: true, get: function () { return ed25519PubCodec_1.Ed25519PubCodec; } });
+const hashing_1 = require("./utils/hashing");
+Object.defineProperty(exports, "Hashing", { enumerable: true, get: function () { return hashing_1.Hashing; } });
+const timestamp_utils_1 = require("./utils/timestamp-utils");
+Object.defineProperty(exports, "TimestampUtils", { enumerable: true, get: function () { return timestamp_utils_1.TimestampUtils; } });
+const validator_1 = require("./utils/validator");
+Object.defineProperty(exports, "Validator", { enumerable: true, get: function () { return validator_1.Validator; } });
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/arrays-utils.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/utils/arrays-utils.d.ts
new file mode 100644
index 0000000..b203384
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/arrays-utils.d.ts
@@ -0,0 +1,5 @@
+export declare class ArraysUtils {
+    static equals(a: Uint8Array, b: Uint8Array): boolean;
+    static toString(array: number[] | Uint8Array): string;
+    static fromString(text: string): Uint8Array;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/arrays-utils.js b/node_modules/@hashgraph/did-sdk-js/dist/utils/arrays-utils.js
new file mode 100644
index 0000000..ffd2187
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/arrays-utils.js
@@ -0,0 +1,28 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ArraysUtils = void 0;
+class ArraysUtils {
+    static equals(a, b) {
+        if (a == b) {
+            return true;
+        }
+        if (!a || !b) {
+            return false;
+        }
+        if (a.length != b.length) {
+            return false;
+        }
+        for (let i = 0; i < a.length; i++) {
+            if (a[i] != b[i])
+                return false;
+        }
+        return true;
+    }
+    static toString(array) {
+        return Buffer.from(array).toString("utf8");
+    }
+    static fromString(text) {
+        return new Uint8Array(Buffer.from(text, "utf8"));
+    }
+}
+exports.ArraysUtils = ArraysUtils;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/ed25519PubCodec.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/utils/ed25519PubCodec.d.ts
new file mode 100644
index 0000000..5734646
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/ed25519PubCodec.d.ts
@@ -0,0 +1,32 @@
+import { BlockCodec, ByteView } from "multiformats/codecs/interface";
+/**
+ * Ed25519PubCodec MULTICODEC(public-key-type, raw-public-key-bytes)
+ * https://github.com/multiformats/js-multiformats#multicodec-encoders--decoders--codecs
+ * Implementation of BlockCodec interface which implements both BlockEncoder and BlockDecoder.
+ * @template T
+ * @typedef {import('./interface').ByteView<T>} ByteView
+ */
+export declare class Ed25519PubCodec implements BlockCodec<number, Uint8Array> {
+    name: string;
+    code: number;
+    encode(data: Uint8Array): ByteView<Uint8Array>;
+    decode(bytes: ByteView<Uint8Array>): Uint8Array;
+    /**
+     * Returns a new Uint8Array created by concatenating the passed ArrayLikes
+     *
+     * @param {Array<ArrayLike<number>>} arrays
+     * @param {number} [length]
+     */
+    private concat;
+    /**
+     * @param {number} num
+     */
+    private varintEncode;
+    /**
+     * Decapsulate the multicodec-packed prefix from the data.
+     *
+     * @param {Uint8Array} data
+     * @returns {Uint8Array}
+     */
+    private rmPrefix;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/ed25519PubCodec.js b/node_modules/@hashgraph/did-sdk-js/dist/utils/ed25519PubCodec.js
new file mode 100644
index 0000000..1905f21
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/ed25519PubCodec.js
@@ -0,0 +1,64 @@
+"use strict";
+// @ts-check
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.Ed25519PubCodec = void 0;
+const varint_1 = __importDefault(require("varint"));
+/**
+ * Ed25519PubCodec MULTICODEC(public-key-type, raw-public-key-bytes)
+ * https://github.com/multiformats/js-multiformats#multicodec-encoders--decoders--codecs
+ * Implementation of BlockCodec interface which implements both BlockEncoder and BlockDecoder.
+ * @template T
+ * @typedef {import('./interface').ByteView<T>} ByteView
+ */
+class Ed25519PubCodec {
+    constructor() {
+        // values retrieved from https://raw.githubusercontent.com/multiformats/multicodec/master/table.csv
+        this.name = "ed25519-pub";
+        this.code = 0xed;
+    }
+    encode(data) {
+        const prefix = this.varintEncode(this.code);
+        return this.concat([prefix, data], prefix.length + data.length);
+    }
+    decode(bytes) {
+        return this.rmPrefix(bytes);
+    }
+    /**
+     * Returns a new Uint8Array created by concatenating the passed ArrayLikes
+     *
+     * @param {Array<ArrayLike<number>>} arrays
+     * @param {number} [length]
+     */
+    concat(arrays, length) {
+        if (!length) {
+            length = arrays.reduce((acc, curr) => acc + curr.length, 0);
+        }
+        const output = new Uint8Array(length);
+        let offset = 0;
+        for (const arr of arrays) {
+            output.set(arr, offset);
+            offset += arr.length;
+        }
+        return output;
+    }
+    /**
+     * @param {number} num
+     */
+    varintEncode(num) {
+        return Uint8Array.from(varint_1.default.encode(num));
+    }
+    /**
+     * Decapsulate the multicodec-packed prefix from the data.
+     *
+     * @param {Uint8Array} data
+     * @returns {Uint8Array}
+     */
+    rmPrefix(data) {
+        varint_1.default.decode(/** @type {Buffer} */ data);
+        return data.slice(varint_1.default.decode.bytes);
+    }
+}
+exports.Ed25519PubCodec = Ed25519PubCodec;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/hashing.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/utils/hashing.d.ts
new file mode 100644
index 0000000..7298cc2
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/hashing.d.ts
@@ -0,0 +1,24 @@
+import { MultibaseDecoder, MultibaseEncoder } from "multiformats/bases/interface";
+export declare class Hashing {
+    static readonly sha256: {
+        digest: (data: Uint8Array | string) => Uint8Array;
+    };
+    static readonly base64: {
+        decode: (encodedString: string) => string;
+        encode: (decodedBytes: string) => string;
+    };
+    static readonly base58: {
+        decode: (encodedString: string) => Uint8Array;
+        encode: (decodedBytes: Uint8Array) => string;
+    };
+    /**
+     * @returns Multibase [MULTIBASE] base58-btc encoded value that is a concatenation of the
+     * MULTIBASE(base58-btc, raw-public-key-bytes)
+     * https://github.com/multiformats/multibase
+     * https://www.w3.org/TR/did-core/#dfn-publickeymultibase
+     */
+    static readonly multibase: {
+        encode: (data: Uint8Array, base?: MultibaseEncoder<string>) => string;
+        decode: (data: string, base?: MultibaseDecoder<string>) => Uint8Array;
+    };
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/hashing.js b/node_modules/@hashgraph/did-sdk-js/dist/utils/hashing.js
new file mode 100644
index 0000000..c678613
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/hashing.js
@@ -0,0 +1,72 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.Hashing = void 0;
+const Base58 = __importStar(require("base58-js"));
+const crypto = __importStar(require("crypto"));
+const js_base64_1 = require("js-base64");
+const base58_1 = require("multiformats/bases/base58");
+class Hashing {
+}
+exports.Hashing = Hashing;
+Hashing.sha256 = {
+    digest: function (data) {
+        const sha256 = crypto
+            .createHash("sha256") // may need to change in the future.
+            .update(data)
+            .digest();
+        return sha256;
+    },
+};
+Hashing.base64 = {
+    decode: function (encodedString) {
+        return js_base64_1.Base64.fromBase64(encodedString);
+    },
+    encode: function (decodedBytes) {
+        return js_base64_1.Base64.toBase64(decodedBytes);
+    },
+};
+Hashing.base58 = {
+    decode: function (encodedString) {
+        return Base58.base58_to_binary(encodedString);
+    },
+    encode: function (decodedBytes) {
+        return Base58.binary_to_base58(decodedBytes);
+    },
+};
+/**
+ * @returns Multibase [MULTIBASE] base58-btc encoded value that is a concatenation of the
+ * MULTIBASE(base58-btc, raw-public-key-bytes)
+ * https://github.com/multiformats/multibase
+ * https://www.w3.org/TR/did-core/#dfn-publickeymultibase
+ */
+Hashing.multibase = {
+    encode: function (data, base = base58_1.base58btc) {
+        return base.encode(data);
+    },
+    decode: function (data, base = base58_1.base58btc) {
+        return base.decode(data);
+    },
+};
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/ipfs.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/utils/ipfs.d.ts
new file mode 100644
index 0000000..ff08aab
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/ipfs.d.ts
@@ -0,0 +1,6 @@
+import { HcsDidCreateDidDocumentEvent } from "../identity/hcs/did/event/document/hcs-did-create-did-document-event";
+export declare class IpfsDidDocumentDownloader {
+    private readonly ipfsHttpProxy;
+    constructor(ipfsHttpProxy?: string);
+    downloadDocument(docEvent: HcsDidCreateDidDocumentEvent): Promise<any>;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/ipfs.js b/node_modules/@hashgraph/did-sdk-js/dist/utils/ipfs.js
new file mode 100644
index 0000000..67f325f
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/ipfs.js
@@ -0,0 +1,39 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.IpfsDidDocumentDownloader = void 0;
+const node_fetch_1 = __importDefault(require("node-fetch"));
+const IPFS_IO_HTTP_PROXY = "https://ipfs.io/ipfs/";
+class IpfsDidDocumentDownloader {
+    constructor(ipfsHttpProxy = IPFS_IO_HTTP_PROXY) {
+        this.ipfsHttpProxy = ipfsHttpProxy;
+    }
+    downloadDocument(docEvent) {
+        var _a;
+        return __awaiter(this, void 0, void 0, function* () {
+            const url = (_a = docEvent.getUrl()) !== null && _a !== void 0 ? _a : `${this.ipfsHttpProxy}/${docEvent.getCid}`;
+            const result = yield (0, node_fetch_1.default)(url);
+            if (!result.ok) {
+                throw new Error(`DID document could not be fetched from URL: ${url}`);
+            }
+            try {
+                return yield result.json();
+            }
+            catch (err) {
+                throw new Error(`DID document from URL could not be parsed as JSON: ${url}`);
+            }
+        });
+    }
+}
+exports.IpfsDidDocumentDownloader = IpfsDidDocumentDownloader;
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/timestamp-utils.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/utils/timestamp-utils.d.ts
new file mode 100644
index 0000000..f172e99
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/timestamp-utils.d.ts
@@ -0,0 +1,10 @@
+import { Timestamp } from "@hashgraph/sdk";
+export declare class TimestampUtils {
+    static ISO: string;
+    static ISO8601: string;
+    static toJSON(item: Timestamp, format?: string): string;
+    static fromJson(json: string, format?: string): Timestamp;
+    static now(): Timestamp;
+    static equals(a: Timestamp, b: Timestamp): boolean;
+    static lessThan(a: Timestamp, b: Timestamp): boolean;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/timestamp-utils.js b/node_modules/@hashgraph/did-sdk-js/dist/utils/timestamp-utils.js
new file mode 100644
index 0000000..7098526
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/timestamp-utils.js
@@ -0,0 +1,45 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.TimestampUtils = void 0;
+const sdk_1 = require("@hashgraph/sdk");
+const moment_1 = __importDefault(require("moment"));
+class TimestampUtils {
+    static toJSON(item, format = this.ISO) {
+        const d = item.toDate();
+        return (0, moment_1.default)(d).utc().format(format);
+    }
+    static fromJson(json, format = this.ISO) {
+        const d = moment_1.default.utc(json, format).toDate();
+        return sdk_1.Timestamp.fromDate(d);
+    }
+    static now() {
+        return sdk_1.Timestamp.fromDate(new Date());
+    }
+    static equals(a, b) {
+        if (a == b) {
+            return true;
+        }
+        if (!a || !b) {
+            return false;
+        }
+        return a.seconds.equals(b.seconds) && a.nanos.equals(b.nanos);
+    }
+    static lessThan(a, b) {
+        if (a == b) {
+            return false;
+        }
+        if (!a || !b) {
+            return false;
+        }
+        if (a.seconds.equals(b.seconds)) {
+            return a.nanos.lessThan(b.nanos);
+        }
+        a.seconds.lessThan(b.seconds);
+    }
+}
+exports.TimestampUtils = TimestampUtils;
+TimestampUtils.ISO = "YYYY-MM-DDTHH:mm:ss.SSS[Z]";
+TimestampUtils.ISO8601 = "YYYY-MM-DDTHH:mm:ss[Z]";
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/validator.d.ts b/node_modules/@hashgraph/did-sdk-js/dist/utils/validator.d.ts
new file mode 100644
index 0000000..e9b3ad9
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/validator.d.ts
@@ -0,0 +1,6 @@
+export declare class Validator {
+    protected validationErrors: string[];
+    addValidationError(errorMessage: string): void;
+    checkValidationErrors(prologue: string, validationFunction: (input: Validator) => void): void;
+    require(condition: boolean, errorMessage: string): void;
+}
diff --git a/node_modules/@hashgraph/did-sdk-js/dist/utils/validator.js b/node_modules/@hashgraph/did-sdk-js/dist/utils/validator.js
new file mode 100644
index 0000000..6fd50e9
--- /dev/null
+++ b/node_modules/@hashgraph/did-sdk-js/dist/utils/validator.js
@@ -0,0 +1,28 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.Validator = void 0;
+const did_error_1 = require("../identity/did-error");
+class Validator {
+    addValidationError(errorMessage) {
+        if (!this.validationErrors) {
+            this.validationErrors = [];
+        }
+        this.validationErrors.push(errorMessage);
+    }
+    checkValidationErrors(prologue, validationFunction) {
+        this.validationErrors = null;
+        validationFunction(this);
+        if (!this.validationErrors) {
+            return;
+        }
+        const errors = this.validationErrors;
+        this.validationErrors = null;
+        throw new did_error_1.DidError(prologue + ":\n" + errors.join("\n"));
+    }
+    require(condition, errorMessage) {
+        if (!condition) {
+            this.addValidationError(errorMessage);
+        }
+    }
+}
+exports.Validator = Validator;
